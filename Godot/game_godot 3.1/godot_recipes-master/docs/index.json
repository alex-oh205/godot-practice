[
{
	"uri": "http://kidscancode.org/godot_recipes/g101/start/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Getting Started Have you downloaded Godot yet? You can get it here: https://godotengine.org\nIn this section:  What is Godot?   Godot\u0026#39;s Editor: Finding your way around   Nodes: Godot\u0026#39;s building blocks   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/g101/3d/101_3d_01/",
	"title": "The 3D Editor",
	"tags": [],
	"description": "",
	"content": " In this tutorial, we\u0026rsquo;ll look at how to start working in 3D in Godot. You\u0026rsquo;ll learn how to navigate in the 3D editor, how to create and manipulate 3D objects, and how to work with some of Godot\u0026rsquo;s essential 3D nodes, such as cameras and lighting.\nAre you ready? A word of warning: 3D development can be quite a bit more complex than working in 2D. While many of the same principles apply - such as working with nodes, writing scripts, and handling logic/data - 3D brings with it a number of other considerations. For this reason, it\u0026rsquo;s a good idea to stick to 2D for your first few projects, moving to 3D once you have a good understanding of the game development process. This tutorial will assume you have completed at least an introductory Godot 2D project, such as the one in the official Godot tutorial.\nGetting Started in 3D One of Godot\u0026rsquo;s strengths is its ability to handle both 2D and 3D games. While much of what you\u0026rsquo;ve learned working on 2D projects (nodes, scenes, signals, etc.) applies equally well in 3D, there is also a whole new layer of complexity and capabilities. First, you\u0026rsquo;ll find that there are some additional features available in the 3D editor window, so we\u0026rsquo;ll start there:\nOrienting in 3D Space When you first open a new project in Godot, you will see the 3D project view:\n 3D view   -- The first thing you should notice is the three colored lines in the center. These are the x (red), y (green), and z (blue) axes. The point where they meet is the origin, which has the coordinates (0, 0, 0). You\u0026rsquo;ll find that this color scheme will also apply elsewhere in the Inspector.\nDifferent 3D applications follow different conventions for orientation. Godot uses Y-Up orientation, so that when looking at the axes, if x is pointing to the left/right, then y is up/down, and z is forward/back. Some other popular 3D software uses Z-UP. It\u0026rsquo;s good to keep this in mind when moving between applications.\n Navigation in 3D is performed using the mouse and keyboard. Here are the basic controls for the view camera:\n Mousewheel up/down: zoom in/out Middle button + drag: orbit camera around current target Shift + middle button + drag: pan camera Right-click + drag: rotate camera in place  In addition, if you\u0026rsquo;re familiar with popular 3D games, you might prefer Freelook mode, which you can toggle on/off using Shift+F. In this mode, you can use the WASD keys to fly around the scene while aiming with the mouse.\nYou can also alter the camera\u0026rsquo;s view by clicking on the [Perspective] label in the upper-left corner. Here, you can snap the camera to a particular orientation.\nAdding 3D Objects Now let\u0026rsquo;s add our first 3D node. Just as all 2D nodes inherit from Node2D, which provides properties such as position and rotation, 3D nodes inherit from Spatial. Add one to your scene and you\u0026rsquo;ll see the following object appear at the origin:\nThis object is not the node. It is something called a 3D gizmo. Gizmos are tools that allow you to move and rotate objects in space. The three rings control rotation, while the three arrows move (translate) the object along the three axes. Note that the rings and arrows are color-coded to match the axis colors.\nTake a few minutes to experiment and get familiar with the gizmo. Use Undo if you find yourself getting lost.\nSometimes you may feel the gizmos are getting in your way. You can click on the mode icons to restrict yourself to only one type of transformation: move, rotate, or scale:  Global vs. Local Space By default, the gizmo controls operate in global space. When you rotate the object, the gizmo\u0026rsquo;s arrows still point along the axes. However, if you click the \u0026ldquo;Local Space Mode\u0026rdquo; button, the gizmo will switch to moving the body in local space.\nNow when you rotate the object, the gizmo arrows point along the object\u0026rsquo;s axes and not the world\u0026rsquo;s. Switching back and forth between Local and World space can make it much easier to place an object exactly where you want it.\nTransforms Look at the Inspector for the Spatial node. Instead of a Position property, you have Translation, as well as Rotation Degrees, and Scale. Drag the object around with the gizmo and observe how these values change.\nYou\u0026rsquo;ll also find a Transform property, which changes as you move the object. A transform is a matrix that describes an object\u0026rsquo;s translation, rotation, and scale all in one. The math behind transforms can get quite complex - you\u0026rsquo;ll start working with them in a later tutorial.\nMeshes Just like a Node2D, a Spatial has no size or appearance of its own. In 2D, you would use a Sprite to add a texture to the node. In 3D, you need to add a mesh. A mesh is a mathematical description of a shape. It consists of a collection of points, called vertices. These vertices are connected by lines, called edges, and multiple edges (at least three) together make a face.\nFor example, a cube is made up of 8 vertices, 12 edges, and 6 faces.\nAdding Meshes Typically, meshes are created by using 3D modeling software, such as Blender. You can also find many collections of 3D models available for download, if you\u0026rsquo;re unable to create your own. However, often you just need a basic shape such as a cube or sphere. In this case, Godot provides a way to create simple meshes called primitives.\nAdd a MeshInstance node as a child of the Spatial and in the Inspector, click its Mesh property:\nHere you can see the list of available primitives. They represent a handy collection of common useful shapes. Select \u0026ldquo;New CubeMesh\u0026rdquo; and you\u0026rsquo;ll see a plain cube appear on the screen. Note that the cube is white by default, although it may appear slightly blue on your screen due to the default ambient lighting. We\u0026rsquo;ll talk about lighting a little bit later.\nCameras Try running the scene with your cube object. Did you see anything? In 3D, you won\u0026rsquo;t see anything in the game viewport without adding a Camera. Add one and use the camera\u0026rsquo;s gizmo to position it pointing towards the cube:\nThe pinkish-purple pyramid shape on the camera is called the fustrum and represents the camera\u0026rsquo;s view. Notice the small triangular arrow which represents the camera\u0026rsquo;s \u0026ldquo;up\u0026rdquo; orientation. As you\u0026rsquo;re moving the camera around, try pressing the \u0026ldquo;Preview\u0026rdquo; button in the upper-left to see what the camera sees. Play the scene to verify everything is working as expected.\nWrapping Up In this tutorial you learned how to use Godot\u0026rsquo;s 3D editor, how to add 3D nodes such as Spatial, MeshInstance, and Camera, and how to use gizmos to place your objects. You also learned a bunch of new terminology. Hopefully you\u0026rsquo;re not overwhelmed.\nIn the next part, we\u0026rsquo;ll look at how to build a 3D scene by importing 3D assets and how to use more of Godot\u0026rsquo;s 3D nodes.\nYou can also find a video version of this lesson here:\n    --\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/g101/start/101_01/",
	"title": "What is Godot?",
	"tags": [],
	"description": "",
	"content": " Game Engines Game development is complex and involves a wide variety of knowledge and skills. In order to build a modern game, you need a lot of underlying technology before you can make the actual game itself. Imagine if you had to build your own computer and write your own operating system before you could even start programming. Game development would be a lot like that if you truly had to start from scratch and build everything you needed.\nIn addition, there are a number of common needs every game has. For example, no matter what your game is, it\u0026rsquo;s going to need to draw things on the screen. If the code to do that has already been written, it makes more sense to reuse it that to create it all over again for every game. This is where game engines come in.\nA game engine is a collection of tools and technologies designed to assist in developing games. This allows you to focus more on building your game, and less on reinventing the wheel. Here are some of the features a good game engine will provide:\n Rendering (2D/3D)  \u0026ldquo;Rendering\u0026rdquo; is the process of displaying your game on the player\u0026rsquo;s screen. A good rendering pipeline needs to work with modern GPU features, high resolution displays, and effects like lighting and perspective, while maintaining a high frame rate.\n Physics  Building an accurate and usable physics engine is an enormous task. Most games require some sort of collision detection and response, and many need simulated physics (ie. friction, inertia, etc.), but few developers want to take on the task of writing one.\n Platform Support  In today\u0026rsquo;s market, you want to be able to release your game on multiple platforms, such as mobile, web, PC, and/or console. A game engine lets you build your game once and export it to one or more platforms.\n Development Environment  All of these tools are brought together in a single application, combining everything into one environment so you don\u0026rsquo;t have to learn a new workflow for every new project.\nThere are dozens of popular game engines to choose from today, such as Unity, Unreal, and GameMaker Studio, to name a few. It is important to remember that the majority of popular engines are commercial products. They may or may not be free to download, but the will require some kind of licensing or royalty agreement if you plan to release your game (and especially if your game makes money). You need to carefully read and understand what you\u0026rsquo;re agreeing to and what you are and are not allowed to do with the engine.\nWhy use Godot?  Click here to download Godot.\nIn contrast to the above, Godot is completely free and open source, released under the very permissive MIT license. This means there are no fees, hidden costs, or royalties you need to pay. This is in addition to being a fully featured modern game engine.\nAs a developer, the benefits are great. Because it\u0026rsquo;s unencumbered by commercial licensing, you have complete control over exactly how and where your game is distributed. In addition, Godot\u0026rsquo;s open source nature also means there is a much greater level of transparency than you\u0026rsquo;ll find with commercial engines. For example, if you find a particular feature doesn\u0026rsquo;t quite meet your needs, you\u0026rsquo;re free to modify the engine itself - no permission required.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/g101/",
	"title": "Godot 101",
	"tags": [],
	"description": "",
	"content": "  Godot 101 Your introduction to the Godot game engine. If you\u0026rsquo;ve never used a game engine before, or if you’re just new to Godot, this is the place to start.\nIn this section:  Getting Started    What is Godot?   Godot\u0026#39;s Editor: Finding your way around   Nodes: Godot\u0026#39;s building blocks    GDScript     Intro to 3D    The 3D Editor   Importing 3D Objects   Creating a 3D Character   Using Areas   Edge Detection \u0026amp; Mouse Capture   Using CSG   First-person Character    "
},
{
	"uri": "http://kidscancode.org/godot_recipes/3d/camera_gimbal/",
	"title": "Camera Gimbal",
	"tags": [],
	"description": "",
	"content": " Problem You need a camera controller, using mouse or keyboard, that remains level while rotating and following a target.\nSolution Try this: take a Camera node and rotate it a small amount around X (the red ring on the gizmo), then a small amount around Z (the blue ring). Now reverse the X rotation and click the \u0026ldquo;Preview\u0026rdquo; button. Observe how the camera is now tilted.\nThe solution to this problem is to place the camera on a gimbal - a device designed to keep an object level during movement. We can create a gimbal using two Spatial nodes, which will control the camera\u0026rsquo;s left/right and up/down rotation respectively.\nThe node setup should look like this:\n- CameraGimbal (Spatial) - InnerGimbal (Spatial) - Camera Set the Transform/Translation of the Camera to (0, 0, 4).\nHere\u0026rsquo;s how the gimbal works: the outer spatial node can only be rotated in Y, while the inner one rotates only in X. You can test this out by rotating them manually, but make sure you change to \u0026ldquo;Local Space Mode\u0026rdquo; first (that\u0026rsquo;s the cube icon next to the lock in the menu bar - the keyboard shortcut to toggle is \u0026ldquo;T\u0026rdquo;). Remember to only move the green ring of the outer node and only the red ring of the inner one. Don\u0026rsquo;t touch the camera node at all.\n Reset all the rotations to 0 once you\u0026rsquo;ve finished experimenting.\nKeyboard control We\u0026rsquo;ll start with the keyboard controls, then add an option to use the mouse as well. Here are the required actions and their assigned inputs:\n   Action Name Input     \u0026quot;cam_up\u0026quot; W   \u0026quot;cam_down\u0026quot; S   \u0026quot;cam_right\u0026quot; D   \u0026quot;cam_left\u0026quot; A   \u0026quot;cam_zoom_in\u0026quot; Wheel Up   \u0026quot;cam_zoom_out\u0026quot; Wheel Down    Here\u0026rsquo;s the initial script. Note that we\u0026rsquo;re making sure to rotate each Spatial in its local space around the specific axis, as described above.\nextends Spatial var rotation_speed = PI/2 func get_input_keyboard(delta): # Rotate outer gimbal around y axis var y_rotation = 0 if Input.is_action_pressed(\u0026#34;cam_right\u0026#34;): y_rotation += 1 if Input.is_action_pressed(\u0026#34;cam_left\u0026#34;): y_rotation += -1 rotate_object_local(Vector3.UP, y_rotation * rotation_speed * delta) # Rotate inner gimbal around local x axis var x_rotation = 0 if Input.is_action_pressed(\u0026#34;cam_up\u0026#34;): x_rotation += -1 if Input.is_action_pressed(\u0026#34;cam_down\u0026#34;): x_rotation += 1 $InnerGimbal.rotate_object_local(Vector3.RIGHT, x_rotation * rotation_speed * delta) func _process(delta): get_input_keyboard(delta) Make a test scene with a MeshInstance and instance the CameraGimbal in it to test out the movement.\nYou\u0026rsquo;ll notice that holding the up/down control will cause the camera to rotate all the way around, eventually becoming upside-down. To prevent this, we can clamp the rotation.\nfunc _process(delta): get_input_keyboard(delta) $InnerGimbal.rotation.x = clamp($InnerGimbal.rotation.x, -1.4, -0.01) The -1.4 value lets it go almost to 90 degrees up, while setting a very small value for the minimum keeps the camera from clipping into the ground. Feel free to experiment with other values.\nMouse control We\u0026rsquo;ll add a flag called mouse_control to enable easy toggling of mouse/keyboard controls.\n# mouse properties var invert_y = false var invert_x = false var mouse_control = false var mouse_sensitivity = 0.005 func _unhandled_input(event): if mouse_control and event is InputEventMouseMotion: if event.relative.x != 0: var dir = 1 if invert_x else -1 rotate_object_local(Vector3.UP, dir * event.relative.x * mouse_sensitivity) if event.relative.y != 0: var dir = 1 if invert_y else -1 $InnerGimbal.rotate_object_local(Vector3.RIGHT, dir * event.relative.y * mouse_sensitivity) func _process(delta): if !mouse_control: get_input_keyboard(delta) This code works by converting horizontal mouse motion to Y rotation of the outer gimbal and vertical to X rotation for the inner gimbal. We\u0026rsquo;ve also added invert_x and invert_y flags so that you can flip the motion in either axis - many players prefer one over the other, so it\u0026rsquo;s best to allow for both options.\nAlso, in _process() we disable keyboard input when using mouse control.\nYou may notice a problem with the up/down movement if you move the mouse too quickly. A large value for event.relative.y results in \u0026ldquo;skipping\u0026rdquo; to the opposite side of the clamped value. We can solve this by clamping the vertical mouse movement to a reasonable value. Change the above code for y to this:\nif event.relative.y != 0: var dir = 1 if invert_y else -1 var y_rotation = clamp(event.relative.y, -30, 30) $InnerGimbal.rotate_object_local(Vector3.RIGHT, dir * y_rotation * mouse_sensitivity) In your project, you\u0026rsquo;ll probably also want to capture the mouse during gameplay. See the linked recipe at the end of this document for details.\n Camera zoom Camera zoom works by varying the scale of the gimbal system.\n# zoom settings var max_zoom = 3.0 var min_zoom = 0.5 var zoom_speed = 0.09 var zoom = 1.5 func _unhandled_input(event): if event.is_action_pressed(\u0026#34;cam_zoom_in\u0026#34;): zoom -= zoom_speed if event.is_action_pressed(\u0026#34;cam_zoom_out\u0026#34;): zoom += zoom_speed zoom = clamp(zoom, min_zoom, max_zoom) func _process(delta): scale = lerp(scale, Vector3.ONE * zoom, zoom_speed) Using lerp() to change the zoom level results in smoother zooming.\nFollowing a target Once you have the camera gimbal set up, it can follow a target by adding the following:\nexport (NodePath) var target func _process(delta): if target: global_transform.origin = get_node(target).global_transform.origin Instance the camera in your scene and use the Inspector to choose the node you want to follow.\nFinal script For completeness, here\u0026rsquo;s the full script, including export variables for all the camera settings, so that you can configure it in your project.\nextends Spatial export (NodePath) var target export (float, 0.0, 2.0) var rotation_speed = PI/2 # mouse properties export (bool) var mouse_control = false export (float, 0.001, 0.1) var mouse_sensitivity = 0.005 export (bool) var invert_y = false export (bool) var invert_x = false # zoom settings export (float) var max_zoom = 3.0 export (float) var min_zoom = 0.4 export (float, 0.05, 1.0) var zoom_speed = 0.09 var zoom = 1.5 func _unhandled_input(event): if Input.get_mouse_mode() != Input.MOUSE_MODE_CAPTURED: return if event.is_action_pressed(\u0026#34;cam_zoom_in\u0026#34;): zoom -= zoom_speed if event.is_action_pressed(\u0026#34;cam_zoom_out\u0026#34;): zoom += zoom_speed zoom = clamp(zoom, min_zoom, max_zoom) if mouse_control and event is InputEventMouseMotion: if event.relative.x != 0: var dir = 1 if invert_x else -1 rotate_object_local(Vector3.UP, dir * event.relative.x * mouse_sensitivity) if event.relative.y != 0: var dir = 1 if invert_y else -1 var y_rotation = clamp(event.relative.y, -30, 30) $InnerGimbal.rotate_object_local(Vector3.RIGHT, dir * y_rotation * mouse_sensitivity) func get_input_keyboard(delta): # Rotate outer gimbal around y axis var y_rotation = 0 if Input.is_action_pressed(\u0026#34;cam_right\u0026#34;): y_rotation += 1 if Input.is_action_pressed(\u0026#34;cam_left\u0026#34;): y_rotation += -1 rotate_object_local(Vector3.UP, y_rotation * rotation_speed * delta) # Rotate inner gimbal around local x axis var x_rotation = 0 if Input.is_action_pressed(\u0026#34;cam_up\u0026#34;): x_rotation += -1 if Input.is_action_pressed(\u0026#34;cam_down\u0026#34;): x_rotation += 1 x_rotation = -x_rotation if invert_y else x_rotation $InnerGimbal.rotate_object_local(Vector3.RIGHT, x_rotation * rotation_speed * delta) func _process(delta): if !mouse_control: get_input_keyboard(delta) $InnerGimbal.rotation.x = clamp($InnerGimbal.rotation.x, -1.4, -0.01) scale = lerp(scale, Vector3.ONE * zoom, zoom_speed) if target: global_transform.origin = get_node(target).global_transform.origin Related recipes  Capturing the Mouse Intro to 3D  Like video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/ai/chase/",
	"title": "Chasing the player",
	"tags": [],
	"description": "",
	"content": " Problem You want an enemy to chase the player.\nSolution The first step in getting an enemy to chase the player is to determine what direction the enemy needs to move. To get the vector pointing from A to B, you subtract: B - A. Normalize the result and you have a direction vector.\nThis makes the solution quite straightforward. Every frame, set the enemy\u0026rsquo;s velocity to point in the direction of the player.\nvelocity = (player.position - position).normalized() * speed Godot\u0026rsquo;s Vector2 object has a built-in helper for this:\nvelocity = position.direction_to(player.position) * speed However, this would allow the enemy to chase the player from any distance, even if it\u0026rsquo;s far away. To fix this, we can add an Area2D to the enemy, and only chase the player when it\u0026rsquo;s inside this \u0026ldquo;detect radius\u0026rdquo;.\nHere\u0026rsquo;s some example code:\nextends KinematicBody2D var run_speed = 25 var velocity = Vector2.ZERO var player = null func _physics_process(delta): velocity = Vector2.ZERO if player: velocity = position.direction_to(player.position) * run_speed velocity = move_and_slide(velocity) func _on_DetectRadius_body_entered(body): player = body func _on_DetectRadius_body_exited(body): player = null We\u0026rsquo;ve connected the body_entered and body_exited signals from the Area2D so that the enemy knows whether it\u0026rsquo;s in range or not.\nThe above assumes that the player is the only body that will enter/exit, which is usually done by setting the appropriate collision layers/masks.\n  This concept can be extended to other types of games as well. The key is to find the direction vector from the enemy to the player:\n# 2D (player.position - position).normalized() # 3D (player.transform.origin - transform.origin).normalized() If, for example, your game is a side-scroller or has other constraints in movement, you can use only the x component of the resulting vector to determine movement.\nLimitations Note that this method results in very simplistic straight-line movement. The enemy will not move around obstacles such as walls, nor will it stop if it gets too close to the player.\nAnother problem is more apparent with fast-moving enemies. As the player moves, the enemies using this technique will change direction instantly. For a more natural-looking movement, you\u0026rsquo;ll want to use a steering behavior.\nFor more advanced behaviors, see the other recipes in this chapter.\nRelated recipes  Top-down character Homing missile  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/enter_exit_screen/",
	"title": "Entering/Exiting the screen",
	"tags": [],
	"description": "",
	"content": " Problem You want to detect when an object enters or exits the screen.\nSolution The engine provides a node for this: VisibilityNotifier2D. Attach this node to your object, and you\u0026rsquo;ll be able to use its screen_entered and screen_exited signals.\nExample 1 Consider a projectile that travels in a straight line after it\u0026rsquo;s fired. If we continue firing, eventually we\u0026rsquo;ll have a large number of objects for the engine to track, event though they\u0026rsquo;re offscreen, which can cause lag.\nHere\u0026rsquo;s the movement code for the projectile:\nextends Area2D var velocity = Vector2(500, 0) func _process(delta): position += velocity * delta To have the projectile automatically deleted when it moves offscreen, add a VisibilityNotifier2D and connect its screen_exited signal.\nfunc _on_VisibilityNotifier2D_screen_exited(): queue_free() Example 2 We have an enemy that performs some actions, such as moving along a path or playing an animation. On a large map with many enemies, only a few of them will be onscreen at the same time. We can disable the enemy\u0026rsquo;s actions while it\u0026rsquo;s offscreen using VisibilityNotifier2D.\nPartial code:\nvar active = false func _process(delta): if active: play_animation() move() func _on_VisibilityNotifier2D_screen_entered(): active = true func _on_VisibilityNotifier2D_screen_exited(): active = false"
},
{
	"uri": "http://kidscancode.org/godot_recipes/math/interpolation/",
	"title": "Interpolation",
	"tags": [],
	"description": "",
	"content": " Interpolation, or its commonly-used abbreviation lerp, is a term that comes up often in game development. If you\u0026rsquo;ve never come across it before it can seem mysterious and highly-technical, but as you\u0026rsquo;ll see in this tutorial, it\u0026rsquo;s actually a straightforward concept with a wide variety of applications in game programming.\nNumeric Interpolation The core formula for linear interpolation is this:\nfunc lerp(a, b, t): return (1 - t) * a + t * b In this formula, a and b represent the two values and t is the amount of interpolation, typically expressed as a value between 0 (which returns a), and 1 (which returns b). The function finds a value the given amountFor example:\nx = lerp(0, 1, 0.75) # x is 0.75 x = lerp(0, 100, 0.5) # x is 50 x = lerp(10, 75, 0.3) # x is 29.5 x = lerp(30, 2, 0.75) # x is 9 It\u0026rsquo;s called linear interpolation because the path between the two points is a straight line.\nYou can animate a node\u0026rsquo;s properties with lerp(). For example, if you divide the elapsed time by the desired duration, you\u0026rsquo;ll get a value between zero and one you can use to alter a property smoothly over time. This script scales a sprite up to five times its starting size while fading it out (using modulate.a) over two seconds:\nextends Sprite var time = 0 var duration = 2 # length of the effect func _process(delta): if time \u0026lt; duration: time += delta modulate.a = lerp(1, 0, time / duration) scale = Vector2.ONE * lerp(1, 5, time / duration) Vector interpolation You can also interpolate between vectors. Both Vector2 and Vector3 provide linear_interpolate() methods for this.\nFor example, to find a vector that\u0026rsquo;s halfway between a Spatial node\u0026rsquo;s forward and left direction vectors:\nvar forward = -transform.basis.z var left = transform.basis.x var forward_left = forward.linear_interpolate(left, 0.5) The following example moves a Sprite node towards the mouse click position. Each frame the node moves 10% of the way to the target. This results in an \u0026ldquo;approach\u0026rdquo; effect, where the object\u0026rsquo;s speed becomes slower the closer it gets to the target.\nextends Sprite var target func _input(event): if event is InputEventMouseButton and event.pressed: target = event.position func _process(delta): if target: position = position.linear_interpolate(target, 0.1) For more advanced applications of interpolation, see Tween.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/ui/labels/",
	"title": "Labels",
	"tags": [],
	"description": "",
	"content": " Problem You want to display some text on the screen.\nSolution Sooner or later you\u0026rsquo;re going to need to display some text on your screen. Examples include a title, countdown timer, score counter, and many others. For the majority of these, Godot\u0026rsquo;s Label node is the answer.\nWorking with fonts Before you can start, you\u0026rsquo;re going to need a font. We\u0026rsquo;ll go into the full details of Godot\u0026rsquo;s font support in a separate recipe, but for our purposes, let\u0026rsquo;s assume you have a TTF or OTF font file. For using bitmap fonts, see the associated recipe.\nFor this example, we\u0026rsquo;ll use \u0026ldquo;Roboto\u0026rdquo; - a popular free font, which you can find on Google Fonts. You can also download here: Roboto_font.zip\n Adding a Label Add a new Label node to your scene. In the Inspector, you\u0026rsquo;ll see the node\u0026rsquo;s properties, most of which are self-explanatory (hover them with the mouse to see a description):\nGo ahead and add something in the Text field and experiment with how it looks. You\u0026rsquo;ll notice there is a default font, but it\u0026rsquo;s very plain (and small).\nAdding a DynamicFont To add your font in the Inspector, scroll down to and expand the Custom Fonts section. In the empty Font property, choose \u0026ldquo;New DynamicFont\u0026rdquo; and then click the new DynamicFont to expand it.\nDrag your font file (in this example we\u0026rsquo;re using Roboto-Medium.ttf) into the Font Data property (or choose \u0026ldquo;Load\u0026rdquo; and navigate to the file). There are several properties to adjust but for now let\u0026rsquo;s make Size a bit bigger.\nFeel free to tinker with how the others affect the text appearance. For example, in the picture below, the second label has the Filter property enabled:\nAdjusting color You can adjust the label\u0026rsquo;s font color in the Custom Colors section. Here you can change Font Color as well as add a shadow color. Shadow properties are set in the Custom Constants section.\nDynamically changing text If all you need in your scene is static text, then you\u0026rsquo;re done. However, if you need to update the label dynamically, you can do so in code by using the text property.\nFor example, if we had a Timer node in our scene, we could do the following:\nextends Control var counter = 0 func _ready(): $Label.text = str(counter) func _on_Timer_timeout(): counter += 1 $Label.text = str(counter) See the \u0026ldquo;related recipes\u0026rdquo; section for more examples of using labels and working with UI nodes.\nDownload the project file here: screen_shake.zip\n -- Related recipes Like video?   -- "
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/platform_character/",
	"title": "Platform character",
	"tags": [],
	"description": "",
	"content": " Problem You need to make a 2D platform-style character.\nSolution New developers are often surprised at how complex a platform character can be to program. Godot provides some built-in tools to assist, but there are as many solutions as there are games. In this tutorial, we won\u0026rsquo;t be going in-depth with features like double-jumps, crouching, wall-jumps, or animation. Here we\u0026rsquo;ll discuss the fundamentals of platformer movement. See the rest of the recipes for other solutions.\nWhile it\u0026rsquo;s possible to use RigidBody2D to make a platform character, we\u0026rsquo;ll be focusing on KinematicBody2D. Kinematic bodies are well-suited for platformers, where you are less interested in realistic physics than in responsive, arcade feel.\n Start with a KinematicBody2D node, and add a Sprite and CollisionShape2D to it.\nAttach the following script to the root node of the character.\nextends KinematicBody2D export (int) var speed = 1200 export (int) var jump_speed = -1800 export (int) var gravity = 4000 var velocity = Vector2.ZERO func get_input(): velocity.x = 0 if Input.is_action_pressed(\u0026#34;ui_right\u0026#34;): velocity.x += speed if Input.is_action_pressed(\u0026#34;ui_left\u0026#34;): velocity.x -= speed func _physics_process(delta): get_input() velocity.y += gravity * delta velocity = move_and_slide(velocity, Vector2.UP) if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): if is_on_floor(): velocity.y = jump_speed The values used for speed, gravity, and jump_speed depend greatly on the size of your player sprite. The player\u0026rsquo;s texture in this example is 108x208 pixels. If your sprite is smaller, you\u0026rsquo;ll want to use smaller values. We also want high values so that everything feels fast and responsive. A low gravity results in a floaty-feeling game while a high value means you\u0026rsquo;re soon back on the ground and ready to jump again.\nNote that we\u0026rsquo;re checking is_on_floor() after using move_and_slide(). The move_and_slide() function sets the value of this method, so it\u0026rsquo;s important not to check it before, or you\u0026rsquo;ll be getting the value from the previous frame.\nFriction and acceleration The above code is a great start, and you can use it as the foundation for a wide variety of platform controllers. One problem it has, though, is the instantaneous movement. For a more natural feel, it\u0026rsquo;s better if the character has to accelerate up to its max speed and that it coasts to a stop when there is no input.\nOne way to add this behavior is to use linear interpolation (\u0026ldquo;lerp\u0026rdquo;). When moving, we will lerp between the current speed and the max speed and while stopping we\u0026rsquo;ll lerp between the current speed and 0. Adjusting the lerp amount will give us a variety of movement styles.\nFor an overview of linear interpolation, see Gamedev Math: Interpolation.\n export (float, 0, 1.0) var friction = 0.1 export (float, 0, 1.0) var acceleration = 0.25 func get_input(): var dir = 0 if Input.is_action_pressed(\u0026#34;walk_right\u0026#34;): dir += 1 if Input.is_action_pressed(\u0026#34;walk_left\u0026#34;): dir -= 1 if dir != 0: velocity.x = lerp(velocity.x, dir * speed, acceleration) else: velocity.x = lerp(velocity.x, 0, friction) Try changing the values for friction and acceleration to see how they affect the game\u0026rsquo;s feel. An ice level, for example, could use very low values, making it harder to maneuver.\nConclusion This code gives you a starting point for building your own platformer controller. For more advanced platforming features such as wall jumps, see the other recipes in this section.\nDownload an example project using this recipe:\nDownload the project file here: platform_character.zip\n Related Recipes  Input Intro Kinematic Friction  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_01/",
	"title": "Project setup",
	"tags": [],
	"description": "",
	"content": " Where to start? Depending on the game, and how fleshed-out your idea is, the answer might be very different. In our case, I\u0026rsquo;ve cheated a little bit by making a prototype of the game already and working out a few of the ideas ahead of time. Still, it diverged a bit from my initial idea, and so might this series - time will tell.\nIn a bigger project, you might start with design document, which could be as simple as a page of notes or as complex as a 500-page treatise laying out every detail of your game\u0026rsquo;s world, plot, and mechanics. We\u0026rsquo;ve no need of anything so involved here, so let\u0026rsquo;s just go over the gameplan.\nGameplan In this game, the player controls a \u0026ldquo;character\u0026rdquo; that jumps from circle to circle. Jumping is initiated by a click or touch, and if you don\u0026rsquo;t hit another circle, you lose. The score is related to how long you survive, and the difficulty will increase over time with circles that move, shrink, and/or expire. The idea is fast-paced, short games with a \u0026ldquo;top that\u0026rdquo; feel. As much as possible, the art will remain simple and clean, with visual and audio effects to add appeal.\nWe\u0026rsquo;ll be using GLES 3 to start. It\u0026rsquo;s not yet clear what if any impact this will have. Once we get to the mobile testing phase, we\u0026rsquo;ll see if a switch to GLES 2 is warranted.\n You can also follow this project on  Github.\nGetting started Let\u0026rsquo;s start with the project settings. We need to define our screen size/ behavior. We want this to be a mobile game so it\u0026rsquo;s going to need to be portrait mode and able to adjust to variable screen sizes, since there are so many phone resolutions available.\nOpen Project Settings and find the Display/Window section. Set the screen size to (480, 854), the Handheld/Orientation to \u0026ldquo;Portrait\u0026rdquo;, the Stretch/Mode to \u0026ldquo;2d\u0026rdquo;, and the Stretch/Aspect to \u0026ldquo;Keep\u0026rdquo;.\nNext, in Input Devices/Pointing enable \u0026ldquo;Emulate Touch From Mouse\u0026rdquo;. This will let us write the code only using screen touch events, but still play by using the mouse on PC platforms.\nProject organization To keep things organized, we\u0026rsquo;re going to make a folder to hold the game objects (objects) and one for UI (gui). The game assets (images, audio, etc.) will go in an assets folder. You can download the starting assets here:\nDownload the project file here: circle_jump_assets.zip\n Once we have the folders and the assets set up, we\u0026rsquo;re ready to start coding!\nGame Objects We have two game objects to make: the player (\u0026ldquo;jumper\u0026rdquo;) and the circle.\nJumper For movement and collision, we\u0026rsquo;re going to use a Area2D. To be fair, we could use KinematicBody2D here too, and it would work just as well. However, we don\u0026rsquo;t really need collision in this game, we just need to know when the jumper contacts a circle. Let\u0026rsquo;s add the following nodes:\n Area2D (\u0026ldquo;Jumper\u0026rdquo;)  Sprite CollisionPolygon2D VisibilityNotifier2D   Save the scene in res://objects/ and drag the circle image (res://assets/images/jumper.png) into the Sprite\u0026rsquo;s Texture. Note that all the game images are flat white. This will make it easier for us to dynamically color them later.\nSince the art is drawn pointing upwards, set the Sprite\u0026rsquo;s Rotation property to 90.\nSelect the CollisionPolygon2D and add three points to cover the jumper\u0026rsquo;s triangular shape.\nNow let\u0026rsquo;s add a script to the body and start coding its behavior:\nFirst, the signals and variables:\nextends Area2D var velocity = Vector2(100, 0) # start value for testing var jump_speed = 1000 var target = null # if we\u0026#39;re on a circle Next we\u0026rsquo;ll detect the screen touch and, if we\u0026rsquo;re on a circle, call our jump method:\nfunc _unhandled_input(event): if target and event is InputEventScreenTouch and event.pressed: jump() Jumping means leaving a circle and traveling forward at our jump speed:\nfunc jump(): target = null velocity = transform.x * jump_speed We\u0026rsquo;ll detect hitting a circle with the area_entered signal, so connect it. If we hit a circle, we\u0026rsquo;ll stop moving forward.\nfunc _on_Jumper_area_entered(area): target = area velocity = Vector2() If we are captured by a circle, we want to rotate around it. We\u0026rsquo;ll add a pivot on the circle, and match its transform so our orientation will always be facing outwards. Otherwise we move forward in a straight line.\nfunc _physics_process(delta): if target: transform = target.orbit_position.global_transform else: position += velocity * delta Color Shader See the Shaders section for help getting started using shaders.\n We\u0026rsquo;re going to use a small shader to the Sprite so that we can customize its color. Select the Sprite and then in the Material property add a new ShaderMaterial. Click on that, and in Shader select \u0026ldquo;New Shader\u0026rdquo;, then click on that. The shader editor panel will open at the bottom.\nHere is the code for our color shader. It uses a uniform variable for the color, which allows us to choose a value from the Inspector or from our game script. Then it changes all the visible pixels of the texture into that color, preserving the alpha (transparency) value.\nshader_type canvas_item; uniform vec4 color : hint_color; void fragment() { COLOR.rgb = color.rgb; COLOR.a = texture(TEXTURE, UV).a; } You\u0026rsquo;ll now see a Shader Params section in the Inspector where you can set a color value:\nWe\u0026rsquo;ll want to use this same shader elsewhere, so in the Shader property, choose \u0026ldquo;Save\u0026rdquo; and save this as res://objects/color.shader.\nCircle The second game object is the circle, which will be instanced many times as the game progresses. Eventually, we\u0026rsquo;ll add a variety of behaviors such as moving, shrinking, etc., but for this first iteration, we just want it to capture the player.\nHere\u0026rsquo;s the starting node setup:\n Area2D (\u0026ldquo;Circle\u0026rdquo;)  Sprite CollisionShape2D Node2D (\u0026ldquo;Pivot\u0026rdquo;)  Position2D (\u0026ldquo;OrbitPosition\u0026rdquo;)    The \u0026ldquo;Pivot\u0026rdquo; node is how we\u0026rsquo;ll make the player orbit the circle. The \u0026ldquo;OrbitPosition\u0026rdquo; will be offset by whatever the size of the circle is, and the player will follow it.\nUse res://assets/images/circle1_n.png as the Sprite\u0026rsquo;s texture. While we\u0026rsquo;re here, add a ShaderMaterial and choose \u0026ldquo;Load\u0026rdquo; to use the saved color.shader we made earlier.\nAdd a circle shape to the CollisionShape2D and attach a script to the root node.\nextends Area2D onready var orbit_position = $Pivot/OrbitPosition var radius = 100 var rotation_speed = PI func _ready(): init() func init(_radius=radius): radius = _radius $CollisionShape2D.shape = $CollisionShape2D.shape.duplicate() $CollisionShape2D.shape.radius = radius var img_size = $Sprite.texture.get_size().x / 2 $Sprite.scale = Vector2(1, 1) * radius / img_size orbit_position.position.x = radius + 25 func _process(delta): $Pivot.rotation += rotation_speed * delta In the init() function, we\u0026rsquo;re setting up the size of the circle, based on the given radius. We need to size the collision shape as well as scaling the texture to match.\nTry running the scene with different values of radius to test. (Later we\u0026rsquo;ll stop calling init() in _ready()).\nMain Scene Now we can test out the interaction.\nCreate a \u0026ldquo;Main\u0026rdquo; scene using a Node2D and instance both the Jumper and the Circle in it. Arrange them so the jumper will hit the Circle (Jumper\u0026rsquo;s default velocity is (100, 0)).\nTry running. You should see the jumper get captured by the circle and start orbiting it. Clicking the mouse should then send the jumper flying off in whatever direction it\u0026rsquo;s pointing.\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nLike video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/screen_wrap/",
	"title": "Screen wrap",
	"tags": [],
	"description": "",
	"content": " Problem You want to allow the player to \u0026ldquo;wrap around\u0026rdquo; the screen, teleporting from one side of the screen to the other. This is a common feature, especially in old-school 2D games (think Pac-man).\nSolution  Get your screen (viewport) size\nonready var screen_size = get_viewport_rect().size get_viewport_rect() is available to any CanvasItem derived node.\n Compare your player\u0026rsquo;s position\nif position.x \u0026gt; screen_size.x: position.x = 0 if position.x \u0026lt; 0: position.x = screen_size.x if position.y \u0026gt; screen_size.y: position.y = 0 if position.y \u0026lt; 0: position.y = screen_size.y Note that this is using the node\u0026rsquo;s position, which is usually the center of your sprite and/or body.\n Simplifying with wrapf()\nThe above code can be simplified using GDScript\u0026rsquo;s wrapf() function, which \u0026ldquo;loops\u0026rdquo; a value between the given limits.\nposition.x = wrapf(position.x, 0, screen_size.x) position.y = wrapf(position.y, 0, screen_size.y)  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/shaders/intro/",
	"title": "Shaders: intro",
	"tags": [],
	"description": "",
	"content": " Problem You want to get started coding shaders.\nSolution A shader is a special program that runs on the computer\u0026rsquo;s GPU (graphics card). The GPU is optimized to perform certain types of math very efficiently. Shader code can be attached to objects to affect how they\u0026rsquo;re rendered on the screen.\nThe output of a shader program is the color of the set of pixels of the object. Shaders can be used in 2d (canvas_item shaders) and 3D (spatial shaders).\nThe most difficult part for newcomers to understand about shaders is that they run in parallel. A shader runs simultaneously on all pixels. This allows for great speed, but also limits what information you have access to in the shader.\nTo add a shader to an object, find its Material property and select \u0026ldquo;New ShaderMaterial\u0026rdquo;. Click the new material to open it, and select \u0026ldquo;New Shader\u0026rdquo;. Click that, and you\u0026rsquo;ll see a shader editor open at the bottom of the screen.\nThe first line of the shader must specify its type. If the node it\u0026rsquo;s attached to is a CanvasItem:\nshader_type canvas_item; Or for a Spatial node:\nshader_type spatial; For these first examples, let\u0026rsquo;s stick to 2D. Add a Sprite node and add shader following the steps above. You can use the Godot icon for its texture.\nThere are two basic types of shader we\u0026rsquo;ll discuss here: vertex and fragment.\nFragment shader Fragment shaders calculate the color of the pixel. Let\u0026rsquo;s look at an example:\nvoid fragment() { COLOR = vec4(1.0, 0.0, 0.0, 1.0); } Every pixel is red. COLOR is the output of the fragment shader and is applied to every pixel simultaneously. But what if we want some variation?\nUV coordinates In shaders, the pixel coordinates are specified in UV notation. These are normalized values ranging from (0, 0) (top-left) to (1, 1) (bottom-right).\nShaders use vectors (vec4) to represent RGBA colors. Individual compenents can be accessed using e.g. color.r. Treating colors as vectors allows for a variety of interesting effects based on vector math.\n void fragment() { COLOR = vec4(UV.x, 0.0, 0.0, 1.0); } Now the red channel ranges from 0 on the left to 1.0 on the right, varying along with the UV.\nAnother example:\nvoid fragment() { COLOR = vec4(UV.x, 1.0 - UV.y, 0.5, 1.0); Textures Notice that since we\u0026rsquo;re setting the pixel color directly, we\u0026rsquo;ve thrown away the Godot icon\u0026rsquo;s data. You can access that texture data using the TEXTURE input and texture() function:\nvoid fragment() { COLOR = texture(TEXTURE, UV); } Now we\u0026rsquo;re back to the original image. Each pixel\u0026rsquo;s color is being set to the color value of the texture at the same UV position.\nIt\u0026rsquo;s also possible to change only one channel of the COLOR output:\nvoid fragment() { COLOR = texture(TEXTURE, UV); COLOR.a = 1.0 - UV.x; } This ramps the alpha channel down, resulting in a fade-out effect.\nVarying with time Another useful built-in shader property is TIME, which gives an ever-increasing value representing the current elapsed time. If we also use the sin() function, which returns a value between -1 and 1, we can produce this effect:\nvoid fragment() { COLOR = texture(TEXTURE, UV); COLOR.a = abs(sin(TIME * 0.5)); } Or this one:\nvoid fragment() { COLOR = texture(TEXTURE, UV); COLOR.a = max(0.0, UV.x - abs(sin(TIME))); } Vertex shader Vertex shaders alter the vertices of the object, allowing for deformations and scaling. Just as fragment shaders run on every pixel, vertex shaders run on every vertex of an object. In a canvas_item shader, this typically means the four corners of the texture. In a spatial shader, it\u0026rsquo;s each vertex of the mesh.\nFor example, observe what happens with the following:\nvoid vertex() { VERTEX.x += UV.x * 10.0; } In this shader, the two left vertices (0, 0) and (0, 1) are unchanged, but the right vertices become (10, 0) and (10, 1).\nVarying the vertex positions over time can produce a variety of interesting effects:\nvoid vertex() { VERTEX.y += sin(UV.x * TIME) * 10.0; } Uniforms To pass a value to the shader, you need a variable declared with the uniform keyword. Once you do this, the variable appears in the Inspector in much the same way an export variable. However, a uniform\u0026rsquo;s value can not be changed in the shader!\nUniform values are global to the shader and can be accessed from any function.\nHints You can also use optional hints to assist in setting the value in the Inspector.\nuniform float radius : hint_range(0, 1); Hints are available for a variety of data types. See the Shader Language Reference for a full list.\nWrapping up This is just a tiny introduction to what\u0026rsquo;s possible with shaders. See the rest of the recipes in this section for more examples you can use in your projects.\nRelated Recipes "
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/splitscreen_demo/",
	"title": "Splitscreen multiplayer",
	"tags": [],
	"description": "",
	"content": " Introduction In this demo, we\u0026rsquo;ll consider a local multiplayer game - a topdown-style maze game with two players (one using arrow keys and the other using WASD controls). This is not a problem if our game world all fits on one screen, but if the map is large, we\u0026rsquo;ll want to have a \u0026ldquo;split screen\u0026rdquo; view tracking the two players separately.\nWe\u0026rsquo;ll also look at a quick way to set up a minimap display.\nGame setup We won\u0026rsquo;t spend a lot of time on the setup of the game world. The two players are KinematicBody2D objects using no-frills 8-way movement.\nIf you need help setting up this part, see the following section in the official Godot docs: 2D Movement Overview.\n Each player has its input actions set up in the Project Settings -\u0026gt; Input Map section: \u0026ldquo;right_1\u0026rdquo; to Right Arrow, \u0026ldquo;right_2\u0026rdquo; to D, etc. Note that by naming them this way, we can save time in the code by using:\nexport var id = 0 func get_input(): velocity = Vector2() if Input.is_action_pressed(\u0026#39;right_%s\u0026#39; % id): velocity.x += 1 # etc. This way both characters can use the same script for movement. Just assign the appropriate value to id for each player.\nThe two players are added to a \u0026ldquo;World\u0026rdquo; scene containing a TileMap:\nIf you like, you can download the starting project, with the world already set up, here:\nsplitscreen_start.zip\nNote that the map is much larger than the game screen, but aside from that everything works as intended. Setting up your game \u0026ldquo;world\u0026rdquo; separately like this will make setting up the viewports much easier and more flexible.\nViewports, Cameras, and Worlds We\u0026rsquo;re going to start with a new scene that\u0026rsquo;s going to contain our two viewports. Create a node to serve as the root. I like to use Node since it has no properties of its own - it\u0026rsquo;s just there to contain the rest of the scene.\nBy themselves, Viewport nodes don\u0026rsquo;t have position information (they don\u0026rsquo;t inherit from Spatial or CanvasItem). We\u0026rsquo;re going to use ViewportContainer, a Control node, to hold each viewport. To keep them arranged side-by-side, we\u0026rsquo;ll use an HBoxContainer.\nSet the HBoxContainer\u0026rsquo;s Alignment to \u0026ldquo;Center\u0026rdquo; and to have a small gap between the two viewports, set Custom Constants/Separation to 5. In the \u0026ldquo;Layout\u0026rdquo; menu, choose \u0026ldquo;Full Rect\u0026rdquo;.\nNow add two ViewportContainers as children, naming them with a 2 and 1 (to match the player they\u0026rsquo;ll display). Set the Size Flags on both to \u0026ldquo;Fill, Expand\u0026rdquo; so that they will each expand to fill half of the screen. Also, check the Stretch property so that the Viewport will automatically be set to the size of the container.\nInside each of these containers add a Viewport. Note that if you set the viewport\u0026rsquo;s Size property, it will be reset by the container.\nIn order for a Viewport to display anything, we\u0026rsquo;ll need a Camera2D which will render onto the Viewport. Add one to each viewport. Don\u0026rsquo;t forget to check the Current property to activate the camera. We can also set each camera\u0026rsquo;s Zoom to (0.75, 0.75) to get a better view of the area around the player.\nYour node setup should look like this:\n┖╴Main (Node) ┖╴Viewports (HBoxContainer) ┠╴ViewportContainer2 ┃ ┖╴Viewport2 ┃ ┖╴Camera2D ┖╴ViewportContainer1 ┖╴Viewport1 ┖╴Camera2D Note that we\u0026rsquo;ve put ViewportContainer1 second in the HBoxContainer. This will place it on the right side since Player 1 uses the arrow keys.\n Adding the World When we run the scene we won\u0026rsquo;t see anything because the viewports don\u0026rsquo;t have any \u0026ldquo;world\u0026rdquo; to render. A viewport\u0026rsquo;s world (for 3D) or world_2d property represent the source for the viewport\u0026rsquo;s environment and determine what will be rendered by its camera. The world can be set in code, but for 2D it will also display any child 2D nodes we add to it.\nLet\u0026rsquo;s instance the \u0026ldquo;World\u0026rdquo; scene as a child of Viewport1. Now when we play the scene we see the world inside the left viewport.\nWe also need to add a world to Viewport2, but we want it to use the same one. We can handle this in code. Attach a script to Main and add the following:\nextends Node onready var viewport1 = $Viewports/ViewportContainer1/Viewport1 onready var viewport2 = $Viewports/ViewportContainer2/Viewport2 onready var camera1 = $Viewports/ViewportContainer1/Viewport1/Camera2D onready var camera2 = $Viewports/ViewportContainer2/Viewport2/Camera2D onready var world = $Viewports/ViewportContainer1/Viewport1/World func _ready(): viewport2.world_2d = viewport1.world_2d The onready node references are for convenience - we\u0026rsquo;ll be using them as we move forward. Remember that when you type \u0026ldquo;$\u0026rdquo; Godot will autosuggest node paths so you don\u0026rsquo;t have to type them. You can also drag a node from the scene tree into the script editor and you\u0026rsquo;ll get the node\u0026rsquo;s path.\nWhen we run the scene now, we see the world rendered in both viewports. However, neither camera is moving so we only see a small part of the world.\nSetting up the cameras Attach the following script to each camera:\nextends Camera2D var target = null func _physics_process(delta): if target: position = target.position Now we can assign a target to each camera and it will follow that node\u0026rsquo;s position. We\u0026rsquo;ll do that in the Main script:\nfunc _ready(): viewport2.world_2d = viewport1.world_2d camera1.target = world.get_node(\u0026#34;Player_1\u0026#34;) camera2.target = world.get_node(\u0026#34;Player_2\u0026#34;) When we run the scene now, each player is centered in its viewport and our splitscreen setup works!\nI find it looks best if you disable the Drag Margin properties of the cameras.\n Camera limits Next, let\u0026rsquo;s add some limits to the player cameras so that they don\u0026rsquo;t scroll outside the bounds of the map. Add this function to the main script and call it in _ready():\nfunc set_camera_limits(): var map_limits = world.get_used_rect() var map_cellsize = world.cell_size for cam in [camera1, camera2]: cam.limit_left = map_limits.position.x * map_cellsize.x cam.limit_right = map_limits.end.x * map_cellsize.x cam.limit_top = map_limits.position.y * map_cellsize.y cam.limit_bottom = map_limits.end.y * map_cellsize.y Minimap Let\u0026rsquo;s add one more fun feature: a minimap showing a zoomed-out view of the entire map so the players can orient themselves.\nWe\u0026rsquo;ll need another ViewportContainer, this one a child of Main. This time, we don\u0026rsquo;t want to use Stretch. Add a Viewport and set its Size to (340, 200) then add a Camera2D. We\u0026rsquo;ll set the Camera2D\u0026rsquo;s Position to (512, 300) to center it on the screen. We\u0026rsquo;ll zoom out by setting Zoom to (9, 9). Don\u0026rsquo;t forget to click Current on this camera as well.\nIn the _ready(), set the minimap to use the same world as the other two viewports:\n$Minimap/Viewport.world_2d = viewport1.world_2d Use the \u0026ldquo;Layout\u0026rdquo; menu to align the Minimap container at \u0026ldquo;Center Bottom\u0026rdquo;. Let\u0026rsquo;s see what it looks like:\nWe need to get rid of that grey area around the edges. We could find the precise zoom level that matches our desired minimap size, but instead, we\u0026rsquo;ll check the Transparent Bg on the Viewport. Now our non-map areas aren\u0026rsquo;t visible and the minimap appears floating directly on top of the main viewports.\nConclusion Viewports can be very powerful, but also confusing. One way of managing them is to try to keep them separate from the game logic and only use them as displays.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/animation/spritesheet_animation/",
	"title": "Spritesheet animation",
	"tags": [],
	"description": "",
	"content": " Problem You want to use a spritesheet containing 2D animations.\nSolution Spritesheets are a common way for 2D animations to be distributed. In a spritesheet, all of the animation frames are packed into a single image.\nFor this demo, we\u0026rsquo;ll be using the excellent \u0026ldquo;Adventurer\u0026rdquo; sprite by Elthen. You can get this and lots of other great art athttps://elthen.itch.io/.\nMake sure the images in your spritesheet are laid out in a constant-sized grid. This will enable Godot to automatically slice them. If they\u0026rsquo;re packed irregularly, you will not be able to use the following technique.\n Node setup This animation technique uses a Sprite node to display the texture, and then we animate the changing frames with AnimationPlayer. This can work with any 2D node, but for this demo, we\u0026rsquo;ll use a KinematicBody2D.\nAdd the following nodes to your scene:\n KinematicBody2D (\u0026ldquo;Player\u0026rdquo;)  Sprite CollisionShape2D AnimationPlayer   Drag the spritesheet texture into the Texture property of the Sprite. You\u0026rsquo;ll see the entire spritesheet displayed in the viewport. To slice it up into individual frames, expand the \u0026ldquo;Animation\u0026rdquo; section in the Inspector and set the Hframes to 13 and Vframes to 8. Hframes and Vframes are the number of horizontal and vertical frames in your spritesheet.\nTry changing the Frame property to see the image change. This is the property we’ll be animating.\nAdding animations Select the AnimationPlayer and click the “Animation” button followed by “New\u0026rdquo; . Name the new animation “idle”. Set the animation length to 2 and click the “Loop” button so that our animation will repeat (see below).\nWith the scrubber at time 0, select the Sprite node. Set its Animation/Frame to 0, then click the key icon next to the value.\nIf you try playing the animation, you\u0026rsquo;ll see it doesn\u0026rsquo;t appear to do anything. That\u0026rsquo;s because the last frame (12) looks the same as the first (0), but we\u0026rsquo;re not seeing any of the frames in-between (1-11). To fix this, change the \u0026ldquo;Update Mode\u0026rdquo; of the track from its default value of \u0026ldquo;Discrete\u0026rdquo; to \u0026ldquo;Continuous\u0026rdquo;. You can find this button at the end of the track on the right side.\nNote that this will only work for spritesheets where the frames are already in order. If they are not, you\u0026rsquo;ll have to keyframe each Frame seperately along the timeline.\nFeel free to add the other animations yourself. For example, the \u0026ldquo;jump\u0026rdquo; animation is on frames 65 through 70.\nRelated recipes  Top-down character Platform character Controlling animation states  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/tilemap_collision/",
	"title": "TileMap: detecting tiles",
	"tags": [],
	"description": "",
	"content": " Problem You have a KinematicBody2D character colliding with a TileMap, and you want to know which tile it collided with.\nSolution When a KinematicBody2D collides, the collision data is returned in a KinematicCollision2D object. The TileMap acts as a single collider, so if you reference the collider property, it will be the TileMap node.\nYou then need to find out which tile in the TileMap is at the collision location.\nAssume you\u0026rsquo;ve obtained a KinematicCollision2D object stored in the variable collision:\n# Confirm the colliding body is a TileMap if collision.collider is TileMap: # Find the character\u0026#39;s position in tile coordinates var tile_pos = collision.collider.world_to_map(position) # Find the colliding tile position tile_pos -= collision.normal # Get the tile id var tile_id = collision.collider.get_cellv(tile_pos) Once you have the tile_id, you can get the tile properties from the TileSet resource, found in the TileMap\u0026rsquo;s tile_set property. For example, to get the name of the tile:\nvar tile_name = collision.collider.tile_set.tile_get_name(tile_id) You can also change the tile by setting it to a new id:\ncollision.collider.set_cellv(tile_pos, new_id) Related recipes  TileMap: using autotile TileMap: animated tiles  Like video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/topdown_movement/",
	"title": "Top-down character",
	"tags": [],
	"description": "",
	"content": " Problem You\u0026rsquo;re making a 2D top-down game, and you want to control a character\u0026rsquo;s movement.\nSolution For this solution, we\u0026rsquo;ll assume you have the following input actions defined:\n   Action Name Key(s)     \u0026quot;up\u0026quot; W,↑   \u0026quot;down\u0026quot; S,↓   \u0026quot;right\u0026quot; D,→   \u0026quot;left\u0026quot; A,←   \u0026quot;click\u0026quot; Mouse button 1    We will also assume you\u0026rsquo;re using a KinematicBody2D character.\nWe can solve this problem in many ways, depending on what type of behavior you\u0026rsquo;re looking for.\nOption 1: 8-way movement In this scenario, the player uses the four directional keys to move (including diagonals).\nextends KinematicBody2D var speed = 200 # speed in pixels/sec var velocity = Vector2.ZERO func get_input(): velocity = Vector2.ZERO if Input.is_action_pressed(\u0026#39;right\u0026#39;): velocity.x += 1 if Input.is_action_pressed(\u0026#39;left\u0026#39;): velocity.x -= 1 if Input.is_action_pressed(\u0026#39;down\u0026#39;): velocity.y += 1 if Input.is_action_pressed(\u0026#39;up\u0026#39;): velocity.y -= 1 # Make sure diagonal movement isn\u0026#39;t faster velocity = velocity.normalized() * speed func _physics_process(delta): get_input() velocity = move_and_slide(velocity) Option 2: Rotate and move In this scenario, the left/right actions rotate the character and up/down move the character forward and back in whatever direction it\u0026rsquo;s facing. This is sometimes referred to as \u0026ldquo;Asteroids-style\u0026rdquo; movement.\nextends KinematicBody2D var speed = 200 var rotation_speed = 1.5 var velocity = Vector2.ZERO var rotation_dir = 0 func get_input(): rotation_dir = 0 velocity = Vector2.ZERO if Input.is_action_pressed(\u0026#39;right\u0026#39;): rotation_dir += 1 if Input.is_action_pressed(\u0026#39;left\u0026#39;): rotation_dir -= 1 if Input.is_action_pressed(\u0026#39;down\u0026#39;): velocity -= transform.x * speed if Input.is_action_pressed(\u0026#39;up\u0026#39;): velocity += transform.x * speed func _physics_process(delta): get_input() rotation += rotation_dir * rotation_speed * delta velocity = move_and_slide(velocity) Option 3: Click and move In this option, the character moves to the clicked location.\nextends KinematicBody2D var speed = 200 var target = null var velocity = Vector2.ZERO func _input(event): if event.is_action_pressed(\u0026#39;click\u0026#39;): target = event.position func _physics_process(delta): if target: look_at(target) velocity = transform.x * speed # stop moving if we get close to the target if position.distance_to(target) \u0026gt; 5 \u0026gt; 5: velocity = move_and_slide(velocity)"
},
{
	"uri": "http://kidscancode.org/godot_recipes/physics/godot3_kinematic2d/",
	"title": "Using KinematicBody2D",
	"tags": [],
	"description": "",
	"content": " Godot offers a number of collision objects to provide both collision detection and response. Trying to decide which one to use for your project can be confusing. You can avoid problems and simplify development if you understand how each each works and what their pros and cons are. In this tutorial, we\u0026rsquo;ll look at the KinematicBody2D node and show some examples of how it can be used.\nIntroduction: Physics bodies In game development you often need to know when two objects in the game space intersect or come into contact. This is known as collision detection. When a collision is detected, you typically want something to happen. This is known as collision response.\nGodot offers three kinds of physics bodies, grouped under the PhysicsBody2D type:\n StaticBody2D  A static body is one that is not moved by the physics engine. It participates in collision detection, but does not move in response to the collision. This type of body is most often used for objects that are part of the environment or that do not need to have any dynamic behavior.\n RigidBody2D  This is the node that implements simulated 2D physics. You do not control a RigidBody2D directly, but instead you apply forces to it (gravity, impulses, etc.) and the physics engine calculates the resulting movement. See Godot 3.0: Rigid Bodies for more information.\n KinematicBody2D  A body that provides collision detection, but no physics. All movement must be implemented in code.\nCollision shapes A physics body can hold any number of Shape2D objects as children. These shapes are used to define the object\u0026rsquo;s collision bounds and to detect contact with other objects.\n Note: In order to detect collisions, at least one Shape2D must be assigned to the object.\n The most common way to assign a shape is by adding a CollisionShape2D or CollisionPolygon2D as a child of the object. These nodes allow you to draw the shape directly in the editor workspace.\n Note: Be careful to never scale your collision shapes in the editor. The Scale property in the Inspector should remain at (1, 1). When changing the size of the collision shape, you should always use the shape\u0026rsquo;s handles, not the Node2D scale handles. Changing the scale can result in unexpected collision behavior.\n !player_coll_shape.png\nCollision Layers and Masks One of the most powerful but frequently misunderstood collision features in Godot is the collision layer system. This system allows you to build up very complex interactions between a variety of objects. The key concepts are layers and masks. Each CollisionObject2D has 32 different physics layers it can interact with.\nLet\u0026rsquo;s look at each of the properties in turn:\n collision_layer describes the layers that the object appears in. By default, all bodies are on layer 1.\n collision_mask describes what layers the body will scan for collisions. If an object isn\u0026rsquo;t in one of the mask layers, the body will ignore it. By default, all bodies scan layer 1.\n  You can also assign names to layers. In \u0026ldquo;Project Settings\u0026rdquo;, look for the \u0026ldquo;Layer Names -\u0026gt; 2D Physics\u0026rdquo; section:\nA body\u0026rsquo;s layer properties can be configured via code, or directly in the Inspector:\nExample:\nYou have three nodes with the following configuration:\n    Layers Mask     Player 1 2, 3   Enemy 2 1   Coin 3 1    In this scenario, the Player node would detect collisions with both Enemy and Coin nodes (because they are in layers it scans). However, Enemy and Coin nodes would not detect each other, because they only scan layers they are not in.\nKinematic Bodies KinematicBody2D is for implementing bodies that are to be controlled via code. They detect collisions with other bodies when moving, but are not affected by engine physics properties like gravity or friction. While this means that you have to write some code to create their behavior, it also means you have more precise control over how they move and react.\n Note: A KinematicBody2D can be affected by gravity and other forces, but you must calculate the movement in code. The physics engine will not move a KinematicBody2D.\n Movement and collision When moving a KinematicBody2D, you should not set its position directly. Instead, you use the move_and_collide() or move_and_slide() methods. These methods move the body along a given vector and will instantly stop if a collision is detected with another body. After a KinematicBody2D has collided, any collision response must be coded manually.\n Note: Kinematic body movement should only be done in the _physics_process() callback.\n move_and_collide This method takes one parameter: a Vector2 indicating the body\u0026rsquo;s relative movement. Typically, this is your velocity vector multiplied by the frame timestep (delta). If the engine detects a collision anywhere along this vector, the body will immediately stop moving. If this happens, the method will return a KinematicCollision2D object.\nKinematicCollision2D When a KinematicBody2D detects a collision, Godot provides a KinematicCollision2D object. This object contains data about the collision and the colliding object. Using this data you can calculate your collision response.\nmove_and_slide The move_and_slide() method is intended to simplify the collision response in the common case where you want one body to slide along the other. This is especially useful in platformers or top-down games, for example.\n NOTE: move_and_slide() automatically calculates frame-based movement using delta. Do not multiply your velocity vector by delta before passing it to move_and_slide().\n In addition to the velocity vector, move_and_slide takes a number of other parameters allowing you to customize the slide behavior:\nfloor_normal - default value: Vector2( 0, 0 )\nThis parameter allows you to define what surfaces the engine should consider to be the floor. Setting this lets you use the is_on_floor(), is_on_wall(), and is_on_ceiling() methods to detect what type of surface the body is in contact with. The default value means that all surfaces are considered walls.\nslope_stop_min_velocity - default value: 5\nThis is the minimum velocity when standing on a slope. This prevents a body from sliding down a slope when standing still.\nmax_bounces - default value: 4\nThis is the maximum number of collisions before the body stops moving. Setting this too low may prevent movement entirely.\nfloor_max_angle - default value: 0.785398 (in radians, equivalent to 45 degrees)\nThis is the maximum angle before a surface is no longer considered a \u0026ldquo;floor\u0026rdquo;.\nWhich to use? A common question from new Godot users is: \u0026ldquo;How do you decide which movement function to use?\u0026rdquo; Often the response is to use move_and_slide() because it\u0026rsquo;s \u0026ldquo;simpler\u0026rdquo;, but this is not necessarily the case. One way to think of it is that move_and_slide() is a special case, and move_and_collide() is more general. For example, the following two code snippets result in the same collision response:\nvar collision = move_and_collide(velocity * delta) if collision: velocity = velocity.slide(collision.normal) velocity = move_and_slide(velocity)\nAnything you do with move_and_slide() can also be done with move_and_collide(), it just might take a little more code. However, as we\u0026rsquo;ll see in the examples below, there are cases where move_and_slide() isn\u0026rsquo;t the response you want.\nExamples Download the Sample Project for the examples below.\nBasic movement If you\u0026rsquo;ve downloaded the sample project, this example is in the \u0026ldquo;BasicMovement.tscn\u0026rdquo; scene.\nFor this example, Add a KinematicBody2D with two children: a Sprite and a CollisionShape2D. As with many demos, we\u0026rsquo;ll use the Godot \u0026ldquo;icon.png\u0026rdquo; as the Sprite\u0026rsquo;s texture (drag it from the Filesystem dock to the \u0026ldquo;Texture\u0026rdquo; property of the Sprite). In the CollisionShape2D\u0026rsquo;s \u0026ldquo;Shape\u0026rdquo; property, select \u0026ldquo;New RectangleShape2D\u0026rdquo; and size the rectangle to fit over the sprite image.\nAttach a script to the KinematicBody2D and add the following code:\nextends KinematicBody2D var speed = 250 var velocity = Vector2() func get_input(): # Detect up/down/left/right keystate and only move when pressed velocity = Vector2() if Input.is_action_pressed(\u0026#39;ui_right\u0026#39;): velocity.x += 1 if Input.is_action_pressed(\u0026#39;ui_left\u0026#39;): velocity.x -= 1 if Input.is_action_pressed(\u0026#39;ui_down\u0026#39;): velocity.y += 1 if Input.is_action_pressed(\u0026#39;ui_up\u0026#39;): velocity.y -= 1 velocity = velocity.normalized() * speed func _physics_process(delta): get_input() move_and_collide(velocity * delta) Run this scene and you\u0026rsquo;ll see that move_and_collide() works as expected, moving the body along the velocity vector. Now let\u0026rsquo;s see what happens when you add some obstacles. Add a StaticBody2D with a rectangular collision shape. For visibility, you can use a sprite, a Polygon2D, or just turn on \u0026ldquo;Visible Collision Shapes\u0026rdquo; from the \u0026ldquo;Debug\u0026rdquo; menu.\nRun the scene again and try moving into the obstacle. You\u0026rsquo;ll see that the KinematicBody2D can\u0026rsquo;t penetrate the obstacle. However, try moving into the obstacle at an angle and you\u0026rsquo;ll find that the obstacle acts like glue - it feels like the body gets stuck.\nThis happens because there is no collision response. move_and_collide() just stops the body\u0026rsquo;s movement when a collision occurs. We need to code whatever response we want from the collision.\nTry changing the function to move_and_slide(velocity) and running again. Note that we removed delta from the velocity calculation.\nmove_and_slide() provides a default collision response of sliding the body along the collision object. This is useful for a great many game types, and may be all you need to get the behavior you want.\nNext, we\u0026rsquo;ll look at a few other examples.\nBouncing/reflecting and collision detection What if you don\u0026rsquo;t want a sliding collision response? For this example (\u0026ldquo;BounceandCollide.tscn\u0026rdquo; in the sample project), we have a character shooting bullets and we want the bullets to bounce off the walls.\nFor this example, we have three scenes: the main scene containing the Player, a Bullet, and a Wall. The Bullet and Wall are separate scenes so that they can be instanced.\nThe Player is controlled by W/S for forward/back and aims using the mouse. Here is the code for the Player, using move_and_slide():\nextends KinematicBody2D export (PackedScene) var Bullet export (int) var speed var velocity = Vector2() func get_input(): # add these actions in Project Settings -\u0026gt; Input Map velocity = Vector2() if Input.is_action_pressed(\u0026#39;backward\u0026#39;): velocity = Vector2(-speed/3, 0).rotated(rotation) if Input.is_action_pressed(\u0026#39;forward\u0026#39;): velocity = Vector2(speed, 0).rotated(rotation) if Input.is_action_just_pressed(\u0026#39;mouse_click\u0026#39;): shoot() func shoot(): # \u0026#34;Muzzle\u0026#34; is a Position2D placed at the barrel of the gun var b = Bullet.instance() b.start($Muzzle.global_position, rotation) get_parent().add_child(b) func _physics_process(delta): get_input() var dir = get_global_mouse_position() - global_position # Don\u0026#39;t move if too close to the mouse pointer if dir.length() \u0026gt; 5: rotation = dir.angle() velocity = move_and_slide(velocity) And the code for the Bullet:\nextends KinematicBody2D var speed = 750 var velocity = Vector2() func start(pos, dir): rotation = dir position = pos velocity = Vector2(speed, 0).rotated(rotation) func _physics_process(delta): var collision = move_and_collide(velocity * delta) if collision: velocity = velocity.bounce(collision.normal) if collision.collider.has_method(\u0026#34;hit\u0026#34;): collision.collider.hit() func _on_VisibilityNotifier2D_screen_exited(): queue_free() The action happens in _physics_process(). After using move_and_collide() if a collision occurs, a KinematicCollision2D object is returned (otherwise, the return is Nil).\nIf there is a returned collision, we use the normal of the collision to reflect the bullet\u0026rsquo;s velocity. bounce() is a Vector2 method.\nIf the colliding object (collider) has a hit method, we also call it. In the example project, we\u0026rsquo;ve added a flashing color effect to the Wall to demonstrate this.\nPlatforming with move_and_slide Let\u0026rsquo;s try one more example - one that often gets asked about - the 2D platformer. move_and_slide() is ideal for quickly getting a functional character controller up and running. If you\u0026rsquo;ve downloaded the sample project, you can find this in \u0026ldquo;Platformer.tscn\u0026rdquo;.\nFor this example, we\u0026rsquo;ll assume you have a level made of StaticBody2D objects. They can be any shape and size. In the sample project, we\u0026rsquo;re using a TileMap to lay out the level, but for the purposes of this demo, they could just as well be individual static bodies.\nWe\u0026rsquo;re also using the adorable \u0026ldquo;Sunny Land\u0026rdquo; art pack by Ansimuz for the art and character animations.\nHere\u0026rsquo;s the code for the player body:\nextends KinematicBody2D export (int) var run_speed export (int) var jump_speed export (int) var gravity enum {IDLE, RUN, JUMP} var velocity = Vector2() var state var anim var new_anim func _ready(): change_state(IDLE) func change_state(new_state): state = new_state match state: IDLE: new_anim = \u0026#39;idle\u0026#39; RUN: new_anim = \u0026#39;run\u0026#39; JUMP: new_anim = \u0026#39;jump_up\u0026#39; func get_input(): velocity.x = 0 var right = Input.is_action_pressed(\u0026#39;ui_right\u0026#39;) var left = Input.is_action_pressed(\u0026#39;ui_left\u0026#39;) var jump = Input.is_action_just_pressed(\u0026#39;ui_select\u0026#39;) if jump and is_on_floor(): change_state(JUMP) velocity.y = jump_speed if right: change_state(RUN) velocity.x += run_speed if left: change_state(RUN) velocity.x -= run_speed $Sprite.flip_h = velocity.x \u0026lt; 0 if !right and !left and state == RUN: change_state(IDLE) func _process(delta): get_input() if new_anim != anim: anim = new_anim $AnimationPlayer.play(anim) func _physics_process(delta): velocity.y += gravity * delta if state == JUMP: if is_on_floor(): change_state(IDLE) velocity = move_and_slide(velocity, Vector2(0, -1)) if position.y \u0026gt; 600: get_tree().reload_current_scene() We\u0026rsquo;re using a very rudimentary state machine to handle the transitions between the character\u0026rsquo;s idle, running, and jumping states.\nWhen using move_and_slide() the function returns a vector representing the movement that remained after the slide collision occurred. Setting that value back to the character\u0026rsquo;s velocity allows us to smoothly move up and down slopes. Try removing velocity = and see what happens if you don\u0026rsquo;t do this.\nAlso note that we\u0026rsquo;ve added Vector2(0, -1) as the floor normal. This is a vector pointing straight upward. This means that if the character collides with an object that has this normal, it will be considered a floor.\nUsing the floor normal allows us to make jumping work, using is_on_floor(). This function will only return true after a move_and_slide() collision where the colliding body\u0026rsquo;s normal is within 45 degrees of the given floor vector (this can be adjusted by setting floor_max_angle).\nThis also allows you to implement other features like wall jumps using is_on_wall(), for example.\nConclusion This introduction only scratches the surface of what\u0026rsquo;s possible with KinematicBody2D. As with all Godot nodes, the API documentation is your friend, so reference it frequently until you\u0026rsquo;re comfortable with the class methods.\nKinematic bodies are so useful, that I\u0026rsquo;ll probably do a followup \u0026ldquo;Know Your Nodes\u0026rdquo; exploring more uses. Please comment below if you have ideas or suggestions for other examples you\u0026rsquo;d like to see.\nDownload the sample project "
},
{
	"uri": "http://kidscancode.org/godot_recipes/physics/godot3_kyn_rigidbody1/",
	"title": "Using Rigid Bodies",
	"tags": [],
	"description": "",
	"content": " This tutorial was written prior to Godot Recipes. Its format will eventually be updated to match the rest of the docs on this site.\n In this tutorial, I\u0026rsquo;ll explain when (and when not) to use rigid bodies, how they work, and demonstrate a few handy tricks to bend them to your will. The examples will use RigidBody2D, but the lessons apply equally to 3D.\nIntroduction  RigidBody2D is the physics body in Godot that provides simulated physics. This means that you don\u0026rsquo;t control a RigidBody2D directly. Instead you apply forces to it (gravity, impulses, etc.) and Godot\u0026rsquo;s built-in physics engine calculates the resulting movement, including collisions, bouncing, rotating, etc.\nYou can modify a RigidBody2D\u0026rsquo;s behavior via properties such as \u0026ldquo;Mass\u0026rdquo;, \u0026ldquo;Friction\u0026rdquo;, or \u0026ldquo;Bounce\u0026rdquo;, which can be set in the Inspector:\nThe body\u0026rsquo;s behavior is also affected by the world, via the Project Settings -\u0026gt; Physics properties, or by entering an  Area2D that is overriding the global physics properties.\nUsing RigidBody2D One of the benefits of using a rigid body is that a lot of behavior can be gotten \u0026ldquo;for free\u0026rdquo; without writing any code. For example, let\u0026rsquo;s look at making a rudimentary \u0026ldquo;Angry Birds\u0026rdquo;-style game with falling blocks. You only need to create RigidBody2Ds for the blocks and projectile, and set their properties. Stacking, falling, and bouncing will automatically be handled by the physics engine.\nStacking blocks Start by making a RigidBody2D for the block and adding Sprite and CollisionShape2D children:\nAdd a texture to the Sprite and a rectangular collision shape. IMPORTANT: Do not change the Scale of the collision shape! In general this is a bad idea, and will result in unexpected collision behavior. Always use the shape\u0026rsquo;s inner size handles and not the outer Node2D-derived scale handles.\n NOTE: For the textures in this example, I\u0026rsquo;m using the Physics Asset pack from Kenney.nl. It contains a wide variety of blocks in different shapes and materials.\n Press \u0026ldquo;Play\u0026rdquo; and you\u0026rsquo;ll see the block fall slowly downward. This is due to the default global gravity. You can find this setting in \u0026ldquo;Project Settings\u0026rdquo; under Physics -\u0026gt; 2d. You can also try changing the Block\u0026rsquo;s Gravity Scale property in the Inspector. I\u0026rsquo;m using a value of 3.\nNow create a Main scene (I usually use a Node) for the root). Add a few StaticBody2D nodes with rectangular collision shapes to serve as your \u0026ldquo;ground\u0026rdquo; and walls.\nInstance a Block, and then duplicate it (Ctrl-D on Windows and Cmd-D on MacOS) so you can make a nice stack. Something like this:\nProjectile Create another scene with the same node setup as your Block, but name this one \u0026ldquo;Ball\u0026rdquo;. Use one of the round textures and a circular collision shape. Instance this in your Main scene and place it somewhere to the side of the stack of blocks.\nTo cause a rigid body to move, it must have some velocity. You can give the body an initial velocity using the Linear -\u0026gt; Velocity property. Try setting this to (500, 0).\nYou can also tinker with the ball\u0026rsquo;s Friction and Bounce properties. Both of these properties can range from zero to one. I like a bounce of around 0.5.\n IMPORTANT: NEVER scale a physics body! If you try, a warning will appear, and when the scene runs, the physics engine will automatically set the scale back to (1, 1).\n Forces Reset the linear velocity to (0, 0). Now what if you want to be able to toss the ball? You should never set a rigid body\u0026rsquo;s velocity or position manually - remember, these are simulating \u0026ldquo;real-world\u0026rdquo; style physics. In the real world, objects can\u0026rsquo;t instantly jump from place to place or from a standstill to a high speed. If you try and do so, the physics engine will resist it, and unexpected movement can occur. Instead, we must apply forces which create an acceleration in a certain direction (also known as Newton\u0026rsquo;s Second Law). Godot physics objects work in the same way.\nTo add force to a rigid body, you have two functions to choose from:\n add_force()  Adds a continuous force to the body. Imagine a rocket\u0026rsquo;s thrust, steadily pushing it faster and faster. Note that this adds to any already existing forces. The force continues to be applied until removed.\n apply_impulse()  Adds an instantaneous \u0026ldquo;kick\u0026rdquo; to the body. Imagine hitting a baseball with a bat.\nWe\u0026rsquo;ll use apply_impulse() to kick the ball when we click, drag, and release the mouse button.\nOpen \u0026ldquo;Project Settings\u0026rdquo; and in the \u0026ldquo;Input Map\u0026rdquo; tab, add a new action called \u0026ldquo;click\u0026rdquo;. Connect it to the left mouse button.\nNext, add a script to the Ball, and add the following code:\nextends RigidBody2D var dragging var drag_start = Vector2() func _input(event): if event.is_action_pressed(\u0026#34;click\u0026#34;) and not dragging: dragging = true drag_start = get_global_mouse_position() if event.is_action_released(\u0026#34;click\u0026#34;) and dragging: dragging = false var drag_end = get_global_mouse_position() var dir = drag_start - drag_end apply_impulse(Vector2(), dir * 5) This script toggles dragging on when the mouse button is pressed and records the location of the click. When the button is released, we find the vector from the click point to the release point and use that to apply the impulse (multiplying by 5 to scale it up). apply_impulse() also takes an offset as its first parameter. This lets you \u0026ldquo;hit\u0026rdquo; the body off center, if you wish. For instance, try setting it to Vector2(25, 0) and you\u0026rsquo;ll add some spin to the ball when it\u0026rsquo;s launched.\nControlling Rigid Bodies There are cases where you need more direct control of a rigid body. For example, imagine you\u0026rsquo;re trying to make a version of the classic game \u0026ldquo;Asteroids\u0026rdquo;. The player\u0026rsquo;s spaceship needs to rotate using the left/right arrow keys, and to move forward when the up arrow is pressed.\nHere\u0026rsquo;s the image I\u0026rsquo;m using for my ship:\nI recommend you also go to OpenGameArt and search for a nice space background (but this is totally optional).\nCreate a new scene for the ship as we did above with the following node structure:\n RigidBody2D  Sprite CollisionShape2D    Note: In Godot 3.0, 0 degrees points to the right (along the x axis). This means you need to add a Rotation of 90 to the Sprite so it will match the body\u0026rsquo;s direction.\n By default, the physics settings provide some damping, which reduces a body\u0026rsquo;s velocity and spin. In space, there\u0026rsquo;s no friction, so there shouldn\u0026rsquo;t be any damping at all. However, for the \u0026ldquo;Asteroids\u0026rdquo; feel, we want the ship to stop rotating when we let go of the keys, so set the ship\u0026rsquo;s Angular -\u0026gt; Damp to 5.\nextends RigidBody2D export (int) var engine_thrust export (int) var spin_thrust var thrust = Vector2() var rotation_dir = 0 var screensize func _ready(): screensize = get_viewport().get_visible_rect().size func get_input(): if Input.is_action_pressed(\u0026#34;ui_up\u0026#34;): thrust = Vector2(engine_thrust, 0) else: thrust = Vector2() rotation_dir = 0 if Input.is_action_pressed(\u0026#34;ui_right\u0026#34;): rotation_dir += 1 if Input.is_action_pressed(\u0026#34;ui_left\u0026#34;): rotation_dir -= 1 func _process(delta): get_input() func _physics_process(delta): set_applied_force(thrust.rotated(rotation)) set_applied_torque(rotation_dir * spin_thrust) Let\u0026rsquo;s walk through what this script is doing. The two variables, engine_thrust and spin_thrust control how fast the ship can accelerate and turn. In the Inspector, set them to 500 and 25000 respectively (the units of torque make for large numbers). thrust will represent the ship\u0026rsquo;s engine state: (0, 0) when coasting, or a vector with the length of engine_thrust when powered on. rotation_dir will represent what direction the ship is turning. The screensize variable will capture the size of the screen, which we\u0026rsquo;ll be using later.\nNext, the input() function captures the keystates and sets the ship\u0026rsquo;s thrust on or off, and the rotation direction (rotation_dir) positive or negative. This function is called every frame in _process().\nFinally, physics-related functions should be called in _physics_process(). Here we use set_applied_force() to apply the thrust in whatever direction the ship is facing. Then we use set_applied_torque() to cause the ship to rotate.\nPlay the scene - you should be able to fly around freely.\nThe Position Problem Another feature of \u0026ldquo;Asteroids\u0026rdquo; is that the screen \u0026ldquo;wraps around\u0026rdquo;. If the player goes off one side, it teleports to the other side. But we already talked above about how you can\u0026rsquo;t change a rigid body\u0026rsquo;s position without breaking the physics engine. This presents a huge problem when working with rigid bodies.\nA common mistake is to try adding something like this to _physics_process():\nfunc _physics_process(delta): if position.x \u0026gt; screensize.x: position.x = 0 if position.x \u0026lt; 0: position.x = screensize.x if position.y \u0026gt; screensize.y: position.y = 0 if position.y \u0026lt; 0: position.y = screensize.y set_applied_force(thrust.rotated(rotation)) set_applied_torque(rotation_dir * spin_thrust) This fails spectacularly, trapping the player on the edge of the screen (with occasional glitches). So why doesn\u0026rsquo;t this work? The docs say _physics_process() is for physics-related stuff, right?\nNot exactly. _physics_process() is synced to the physics timestep, but that doesn\u0026rsquo;t make it OK to use for just anything. Hope is not lost, however, the answer is in the docs.\nTo quote the RigidBody2D docs:\n You should not change a RigidBody2D’s position or linear_velocity every frame or even very often. If you need to directly affect the body’s state, use _integrate_forces, which allows you to directly access the physics state.\n And the description for _integrate_forces:\n Allows you to read and safely modify the simulation state for the object. Use this instead of _physics_process if you need to directly change the body’s position or other physics properties.\n So there\u0026rsquo;s our answer. Instead of using _physics_process() we need to use _integrate_forces(), which gives us access to the Physics2DDirectBodyState. I highly recommend you take a look at the linked document, there is a lot of really useful data provided in the physics state object. For our purposes, the key piece of information is the body\u0026rsquo;s Transform2D. (Explaining transforms is beyond the scope of this document - see Matrices and transforms for more information.)\nThe body\u0026rsquo;s position is contained in the transform\u0026rsquo;s origin. Change _physics_process() to _integrate_forces() and add the following code:\nfunc _integrate_forces(state): set_applied_force(thrust.rotated(rotation)) set_applied_torque(rotation_dir * spin_thrust) var xform = state.get_transform() if xform.origin.x \u0026gt; screensize.x: xform.origin.x = 0 if xform.origin.x \u0026lt; 0: xform.origin.x = screensize.x if xform.origin.y \u0026gt; screensize.y: xform.origin.y = 0 if xform.origin.y \u0026lt; 0: xform.origin.y = screensize.y state.set_transform(xform) We grab the current transform, change it as necessary, and set it back as the new transform. The physics engine stays happy, and everything works as expected:\nConclusion When used properly, rigid bodies are a powerful tool in your Godot toolkit. Many users get in trouble, however, when they use them for the wrong purposes, or fail to understand exactly how they work.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/g101/start/101_02/",
	"title": "Godot&#39;s Editor: Finding your way around",
	"tags": [],
	"description": "",
	"content": " Project Manager The Project Manager is the first thing you\u0026rsquo;ll see when opening Godot.\nIn this window you can see a list of your Godot projects. You can choose an existing project and click \u0026ldquo;Run\u0026rdquo; to play the game or click \u0026ldquo;Edit\u0026rdquo; to work on it in the Godot editor. Since you probably don\u0026rsquo;t have any projects yet, let\u0026rsquo;s start by clicking the \u0026ldquo;New Project\u0026rdquo; button.\nHere you can give the project a name and create a folder to store it in.\nEvery Godot project is contained in its own folder. This has many benefits, including making it easy to move, share, and backup projects. It also means that all the project\u0026rsquo;s files (images, sounds, etc.) must be in the project folder.\n When you\u0026rsquo;re naming your project, try to choose a name that describes the project. \u0026ldquo;New Game Project #23\u0026rdquo; is not going to help you remember what that project was. You should also think about compatibility: some operating systems are case-sensitive, and some are not. This can lead to problems if you move or share your project from one computer to another. For this reason, many programmers develop a standardized naming scheme. For example: \u0026ldquo;No spaces, use \u0026lsquo;_\u0026rsquo; between words.\u0026rdquo;\nLet\u0026rsquo;s name this new project \u0026ldquo;getting_started\u0026rdquo;. Type this name, click \u0026ldquo;Create Folder\u0026rdquo;, and then click \u0026ldquo;Create \u0026amp; Edit\u0026rdquo;.\nYou\u0026rsquo;re now looking at the Godot editor window. This is where you\u0026rsquo;ll spend most of your time when working in Godot. The editor is divided into sections.\n Viewport: This is where you\u0026rsquo;ll see the parts of your game as you\u0026rsquo;re working on them. Main Menu: Here you can save and load files, edit project settings, and search for help. Workspaces: At the center-top, you can switch between working in the 2D, 3D, or Script workspaces. You start in 3D. Playtest Buttons: These buttons let you launch and control your game when testing. Docks: On both sides are a number of docks where you can view game items and set their properties.  Project Settings Now we\u0026rsquo;ve talked about the main parts of the Godot window and how they work, let\u0026rsquo;s spend a little time talking about our Project settings. Usually one of the first tasks when starting a new project is make sure it\u0026rsquo;s all set up correctly.\nSo let\u0026rsquo;s click on \u0026ldquo;Project\u0026rdquo; in the menu and select \u0026ldquo;Project Settings\u0026rdquo;.\nThis is the Project settings window. On the left is a list of categories. For most projects, the default settings will be fine, and you shouldn\u0026rsquo;t worry about changing them unless you have a very specific need. For now, we\u0026rsquo;re just going to look at two of the sections. First, \u0026ldquo;Application/Config\u0026rdquo;.\nIn here, you can set your game\u0026rsquo;s title, choose which scene is the \u0026ldquo;main scene\u0026rdquo; (more about that in a bit), and change the icon.\nSecond, let\u0026rsquo;s look at the \u0026ldquo;Display\u0026rdquo; section. This is where you set up your game\u0026rsquo;s display. width \u0026amp; height let you set the size of the game window. If, for example, you were making a mobile game, you\u0026rsquo;d want to set this to the resolution and proportions of your target device. There are also settings for scaling, stretching, fullscreen mode, and more. For now, we\u0026rsquo;ll leave the default size - later on we\u0026rsquo;ll talk about how to adjust these to get our game running on different devices.\nThere are also some tabs across the top. We\u0026rsquo;ve been looking at the \u0026ldquo;General\u0026rdquo; tab. I\u0026rsquo;ll also point out briefly, the \u0026ldquo;Input Map\u0026rdquo;. This is where you can define different input actions for keyboard control, gamepad, mouse, and so on. In your game, you\u0026rsquo;ll just worry about the action, not what individual key or button was pressed. This is a very powerful and flexible way of handling player input.\nWe also have localization options, if you plan to support multiple languages. Autoloading, which we\u0026rsquo;ll get to later, and plugins. The Godot community has created a variety of useful plugins that you can download and add to supply more features, different tools, and so on.\nWe\u0026rsquo;ll come back to the project settings window later. Let\u0026rsquo;s close it for now and we\u0026rsquo;re ready to move on to the next step: working with nodes.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/basics/",
	"title": "Basics",
	"tags": [],
	"description": "",
	"content": "  Basics Basic Godot tips and tricks that apply to any project.\nIn this section:  Understanding \u0026#39;delta\u0026#39;   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/g101/3d/101_3d_02/",
	"title": "Importing 3D Objects",
	"tags": [],
	"description": "",
	"content": " In the last part, we started a 3D project and looked at how to navigate and create 3D objects. In this part, you\u0026rsquo;ll learn how to import existing 3D objects that you\u0026rsquo;ve made or downloaded and how to use more of Godot\u0026rsquo;s 3D nodes.\nImporting 3D Objects If you\u0026rsquo;re familiar with 3D modeling software such as Blender, you can make your own models to use in your game. If not, there are many sources where you can download objects or even collections of objects for particular game types. One of our favorite makers of free game art is Kenney.nl.\nFor our tutorials, we\u0026rsquo;re going to use Kenney\u0026rsquo;s Platformer Kit, which you can download here: https://kenney.nl/assets/platformer-kit\nThis kit has a wide selection of objects that we can use to practice our Godot 3D skills. Here\u0026rsquo;s a sample showing what the kit looks like:\nOnce you\u0026rsquo;ve downloaded the kit, you\u0026rsquo;ll find that the objects inside are provided in a variety of different formats. Godot is able to use several of these, but since GLTF is available in this pack, it\u0026rsquo;s preferred over the others. Copy the \u0026ldquo;GLTF Format\u0026rdquo; folder into your Godot project\u0026rsquo;s folder and rename it to \u0026ldquo;platformer kit\u0026rdquo;.\nIf you\u0026rsquo;re interested in the differences between the formats, here\u0026rsquo;s a brief summary: OBJ files are the simplest, each representing a mesh which you can load into a MeshInstance node. This is likely the most common file type you\u0026rsquo;ll find online. DAE (Collada) files are more robust - Godot loads them as individual scenes, and they can include additional data along with the mesh such as animations. GLTF files are similar, but represent a more modern format with additional features.\n When you switch back to your Godot window, you\u0026rsquo;ll see progress bar while Godot scans the folder and imports all of the objects. Let\u0026rsquo;s click on one of them to see what\u0026rsquo;s going on. In the \u0026ldquo;FileSystem\u0026rdquo; tab, select the \u0026ldquo;crate.glb\u0026rdquo; and then click on the \u0026ldquo;Import\u0026rdquo; tab:\nHere you can see the cube object will be imported as a scene, with its root type set to Spatial and named \u0026ldquo;Scene Root\u0026rdquo;. Let\u0026rsquo;s change these: set the root type to RigidBody and the root name to \u0026ldquo;Crate\u0026rdquo;, then click the \u0026ldquo;Reimport\u0026rdquo; button.\nNow double-click on \u0026ldquo;crate.glb\u0026rdquo; and confirm that you want to make a new inherited scene. Here we have a classic game object: the crate. The root node of the scene is a RigidBody named \u0026ldquo;Crate\u0026rdquo; just as we wanted. However, there\u0026rsquo;s one small problem: it seems Kenney exported this model with an offset:\nIt would much better if the crate were centered relative to the parent node, so that when the RigidBody rotates about its center, so will the mesh. To fix this, select the MeshInstance node and set its Translation property to (-0.5, -0.25, 0.5).\nFinally, we need to add a collision shape to the body. Add a CollisionShape node as a child of the Crate. In its Shape property, choose \u0026ldquo;New BoxShape\u0026rdquo;. Use the three handles (they look like orange circles) to size the box to fit the mesh. You can also set the extents directly in the Inspector:\nNote that since the crate is 0.5 units wide, the Extents, which represent the distance from the center, becomes 0.25 units.\nNow we\u0026rsquo;re finished setting up the object. Save your Crate scene and let\u0026rsquo;s see how we can use it.\nBuilding a 3D Scene Create a new scene with a Spatial root. The first child we\u0026rsquo;ll add is one to give us a \u0026ldquo;ground\u0026rdquo; to stack some crates on. Add a StaticBody called \u0026ldquo;Ground\u0026rdquo;, and to that add a MeshInstance. In the Mesh property, select \u0026ldquo;New PlaneMesh\u0026rdquo; and then click it to open its properties. Set Size to (10, 10) so that we have a nice large surface. However, it would look better if it weren\u0026rsquo;t plain white.\nAlso in the mesh properties is a Material property. Materials are how you define the appearance of an object. Select \u0026ldquo;New SpatialMaterial\u0026rdquo; and then click it to open a large list of properties. To set the color of the mesh, we need the Albedo property. Choose a color, such as brown or dark green.\nIf we add a crate, it will fall right through the mesh, so we also need to give it a collision shape. With the crate, we added a CollisionShape node and assigned a shape. That\u0026rsquo;s one way to add collision, let\u0026rsquo;s look at another: select the mesh and in the menu at the of the viewport, choose \u0026ldquo;Create Convex Collision Sibling\u0026rdquo;. This will automatically create a CollisionShape node as a sibling of the mesh and assign it a shape that matches the mesh.\nNow instance a few crates in the scene and arrange them in a rough stack. Add a Camera and place it where it has a good view of the crates. Run the scene and watch your crates go tumbling!\nRotating Camera Let\u0026rsquo;s make the camera a little more dynamic by having it slowly orbit around the scene. Add a Spatial, which will be located at (0, 0, 0) and name it \u0026ldquo;CameraHub\u0026rdquo;. In the scene tree, drag the camera to make it a child of this new Spatial. Now, if the Spatial rotates around the y axis, it will drag the camera along with it.\nAdd a script to the root node and add the following:\nextends Spatial func _process(delta): $CameraHub.rotate_y(0.01) Run the scene to see what happens.\nLighting There\u0026rsquo;s another thing we can add to the scene to improve how it looks: light. There are multiple light nodes available in 3D, but we\u0026rsquo;re going to start with DirectionalLight. Add one to the scene and use the green (Y) arrow to pull it up into the air.\nA DirectionalLight simulates an infinite number of parallel rays of light, as if from a distant source like the sun. It will not cast shadows by default; to add shadows, click Enabled in the \u0026ldquo;Shadow\u0026rdquo; section. There is also a \u0026ldquo;DirectionalShadow\u0026rdquo; section, which contains a number of advanced properties for fine-tuning the shadow appearance. For full details see this document.\nNote that it really doesn\u0026rsquo;t matter where you place the node - only the direction of the light arrow matters.\nWrapping Up In this tutorial you learned how to import 3D objects from outside sources, and how to combine them into a simple scene. We also investigated lights and moving cameras.\nIn the next part, we\u0026rsquo;ll look at how to build a more complex scene and include a player-controlled character.\nYou can also find a video version of this lesson here:\n    --\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/ui/containers/",
	"title": "Containers",
	"tags": [],
	"description": "",
	"content": " Problem Your UI has problem(s): it\u0026rsquo;s become overcomplicated, it doesn\u0026rsquo;t resize well, and/or you can\u0026rsquo;t keep track of how everything fits together.\nSolution For many developers, building a UI is their least favorite part. It\u0026rsquo;s very easy for a complex UI to spiral out of control and become impossibly painful to fix or modify. Godot provides some great tools for building UI - and if you take the time to learn to use them, you\u0026rsquo;ll find that they take away a lot of that pain.\nThe solution is the Container. Containers provide a lot of power in building your UI\u0026rsquo;s layout.\nWhen a Control node is added to a Container, the container takes over all the control\u0026rsquo;s positioning information. You can no longer set the size, position, or other layout properties of the container\u0026rsquo;s children.\nThis is the key thing to remember about containers:\nA Container node automatically arranges its children. You cannot directly control the position of a child UI node.\n Let\u0026rsquo;s look at some of the most commonly used containers:\n CenterContainer\nThis container places keeps its children centered.\n MarginContainer\nThis container maintains a margin, preventing children from getting too close to the edges of the container. Margin values can be set in the \u0026ldquo;Custom Constants\u0026rdquo; section of the properties.\n VBox/HboxContainer\nThese containers keep their contents aligned vertically or horizontally, respectively. In the \u0026ldquo;Custom Constants\u0026rdquo; section you can also set a Separation property to increase spacing between elements.\n GridContainer\nThis container arranges its children in a grid pattern.\n  Size flags The way a container handles its children is mainly controlled by their \u0026ldquo;Size Flags\u0026rdquo; properties.\n Fill\nWhen this option is checked, the control fills its assigned location in the container. This option is enabled by default.\n Expand\nIf this option is checked, the control tries to use as much space as it can. Nodes without Expand selected are pushed by those that do.\n Shrink Center\nWhen Fill is disabled and Expand is enabled, the control remains at the center of its area, rather than the beginning.\n Shrink End\nSame as above, except the control stays to the end rather than the beginning.\n Stretch Ratio\nThis ratio sets the amount that expanding controls take up relative to each other.\n  A good way to experiment with these settings is to set up a test scene like the following:\nTry adjusting the \u0026ldquo;Size Flags\u0026rdquo; properties of the different buttons and see how it affects their positioning in the HBoxContainer.\nNesting Containers For more complex UI setups, you\u0026rsquo;ll need to use containers holding other containers. Each item in a GridContainer, for example, may itself be a VBoxContainer, with all of it inside a MarginContainer.\nAll these containers inside containers can cause your scene tree to become quite large and hard to manage, especially if you have a lot of repeated elements, such as buttons and labels. It\u0026rsquo;s recommended that you break your UI into pieces and save each part as a separate scene that you can instance in the larger scene.\nDownload the project file here: screen_shake.zip\n -- Related recipes  Labels    -- "
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/grid_movement/",
	"title": "Grid-based movement",
	"tags": [],
	"description": "",
	"content": " Problem You need a 2D character that moves in a grid pattern.\nSolution Grid- or tile-based movement means the character\u0026rsquo;s position is restricted. They can only stand on a particular tile - never between two tiles.\nCharacter setup Here are the nodes we\u0026rsquo;ll use for the player:\n Area2D (\u0026ldquo;Player\u0026rdquo;): Using an Area2D means we can detect overlap (for picking up objects or colliding with enemies).  Sprite: You can use a sprite sheet here (we\u0026rsquo;ll set up the animation below). CollisionShape2D: Don\u0026rsquo;t make the hitbox too big. Since the player will be standing on the center of a tile, overlaps will be from the center. RayCast2D: For checking if movement is possible in the given direction. Tween: For interpolating movement from tile to tile. AnimationPlayer: For playing the character\u0026rsquo;s walk animation(s).   Add some input actions to the Input Map. We\u0026rsquo;ll use \u0026ldquo;up\u0026rdquo;, \u0026ldquo;down\u0026rdquo;, \u0026ldquo;left\u0026rdquo;, and \u0026ldquo;right\u0026rdquo; for this example.\nBasic movement We\u0026rsquo;ll start by setting up the tile-by-tile movement, without any animations or interpolation.\nextends Area2D var tile_size = 64 var inputs = {\u0026#34;right\u0026#34;: Vector2.RIGHT, \u0026#34;left\u0026#34;: Vector2.LEFT, \u0026#34;up\u0026#34;: Vector2.UP, \u0026#34;down\u0026#34;: Vector2.DOWN} tile_size should be set to match the size of your tiles. In a larger project, this can be set by your main scene when instancing the player. We\u0026rsquo;re using 64x64 tiles in the example below.\nThe inputs dictionary maps the input action names to direction vectors. Make sure you have the names spelled the same here and in the Input Map (capitalization counts!).\nfunc _ready(): position = position.snapped(Vector2.ONE * tile_size) position += Vector2.ONE * tile_size/2 snapped() allows us to \u0026ldquo;round\u0026rdquo; the position to the nearest tile increment, and adding a half-tile amount makes sure the player is centered on the tile.\nfunc _unhandled_input(event): for dir in inputs.keys(): if event.is_action_pressed(dir): move(dir) func move(dir): position += inputs[dir] * tile_size Here\u0026rsquo;s the actual movement code. When an input event occurs, we check the four directions to see which one matched, then pass it to move() to change the position.\nCollision Now we can add some obstacles. You can add StaticBody2Ds to manually add some obstacles (enable snapping to make sure they\u0026rsquo;re aligned with the grid) or use a TileMap (with collisions defined), as in the example below.\nWe\u0026rsquo;ll use the RayCast2D to determine whether a move to the next tile is allowed.\nonready var ray = $RayCast2D func move(dir): ray.cast_to = inputs[dir] * tile_size ray.force_raycast_update() if !ray.is_colliding(): position += inputs[dir] * tile_size When changing a raycast\u0026rsquo;s cast_to property, the physics engine won\u0026rsquo;t recalculate its collisions until the next physics frame. force_raycast_update() lets you update the ray\u0026rsquo;s state immediately. If it\u0026rsquo;s not colliding, then we allow the move.\nAnother common method is to use 4 separate raycasts, one for each direction.\n Animating movement Lastly we can interpolate the position between tiles, giving a smooth feel to the movement. We\u0026rsquo;ll use the Tween node to animate the position property.\nonready var tween = $Tween export var speed = 3 Add a reference to the Tween node and a variable to set our movement speed.\nfunc _unhandled_input(event): if tween.is_active(): return for dir in inputs.keys(): if event.is_action_pressed(dir): move(dir) We\u0026rsquo;ll ignore any input while the tween is running.\nfunc move(dir): ray.cast_to = dir * tile_size ray.force_raycast_update() if !ray.is_colliding(): #\tposition += dir * tile_size move_tween(dir) Remove the direct position change and call a function to activate the tween:\nfunc move_tween(dir): tween.interpolate_property(self, \u0026#34;position\u0026#34;, position, position + dir * tile_size, 1.0/speed, Tween.TRANS_SINE, Tween.EASE_IN_OUT) tween.start() Experiment with different tween transitions for different movement effects.\nYou can download a complete project of this example: grid_based_movement.zip\nRelated Recipes  Input Actions Interpolation  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/input/input_actions/",
	"title": "Input Actions",
	"tags": [],
	"description": "",
	"content": " Problem You want to understand Godot\u0026rsquo;s \u0026ldquo;input action\u0026rdquo; system.\nSolution Let\u0026rsquo;s say you\u0026rsquo;re making a top-down character and you write code using InputActionKey that uses the arrow keys for movement. You\u0026rsquo;ll quickly find that many players prefer to use \u0026ldquo;WASD\u0026rdquo; style controls. You can go back into your code and add the additional key checks, but this would result in duplicated/redundant code.\nInput actions can help to make your code more configurable. Rather than hard-coding specific keys, you\u0026rsquo;ll be able to modify and customize them without changing the code.\nCreating inputs You define input actions in the \u0026ldquo;Project Settings\u0026rdquo; under the \u0026ldquo;Input Map\u0026rdquo; tab. Here, you can create new actions and/or assign inputs to them.\nYou\u0026rsquo;ll see when you click on the tab there are already some default actions configured. They are all named \u0026ldquo;ui_*\u0026rdquo; to indicate that they are the default interface actions. \u0026ldquo;Tab\u0026rdquo; for next UI element, for example.\nGenerally speaking, you should create your own actions for your game, rather than use the existing ones.\nFor this example, let\u0026rsquo;s say you want to allow the player to control the game with the keyboard or the mouse. They need to be able to shoot by pressing either the left mouse button or the spacebar.\nCreate the new action \u0026ldquo;shoot\u0026rdquo; by typing the name in the \u0026ldquo;Action\u0026rdquo; field at the top and clicking \u0026ldquo;Add\u0026rdquo; (or pressing enter). Scroll to the bottom and you\u0026rsquo;ll see the new action has been added to the list.\nNow you can assign inputs to this action by clicking the \u0026ldquo;+\u0026rdquo; sign to the right. Inputs can be keys, mouse buttons, or joy/gamepad inputs. Choose \u0026ldquo;Key\u0026rdquo; and you can press the key on the keyboard you want to assign - let\u0026rsquo;s press the spacebar - and click \u0026ldquo;OK\u0026rdquo;.\nClick \u0026ldquo;+\u0026rdquo; to add another input, and this time choose \u0026ldquo;Mouse Button\u0026rdquo;. The default of \u0026ldquo;Device 0\u0026rdquo; and \u0026ldquo;Left Button\u0026rdquo; is fine, but you can select others if you like.\nUsing input actions You can check for the action either by polling the Input singleton every frame:\nfunc _process(delta): if Input.is_action_pressed(\u0026#34;shoot\u0026#34;): # This will execute every frame as long as the input is held. This is best for continuous actions - i.e. those you want to check constantly, such as movement.\nIf instead you want to detect the action at the moment it occurs, you can use the _input() or _unhandled_input() callbacks:\nfunc _unhandled_input(event): if event.is_action_pressed(\u0026#34;shoot\u0026#34;): # This will run once on the frame when the action is first pressed There are several functions you can use for checking input state:\n is_action_pressed(): This function returns true if the action is currently in the pressed state.\n is_action_released(): This function returns true if the action is not In the pressed state.\n is_action_just_pressed() / is_action_just_released(): These methods work like the above, but only return true on the single frame after the event occurs. This is useful for non-recurring actions like shooting or jumping where the user needs to let go and then press the key again to repeat the action.\n  Related Recipes  Inputs: Introduction  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/shaders/interacting/",
	"title": "Interacting with Shaders",
	"tags": [],
	"description": "",
	"content": " Problem You want to interact with a Godot shader from GDScript.\nSolution To access the uniform\u0026rsquo;s value from GDScript, you can use set_shader_param() on the object\u0026rsquo;s material property. If the attached material is a ShaderMaterial, then you can access it like so:\nnode.material.get_shader_param(\u0026#34;param_name\u0026#34;, value) You can also change the value with set_shader_param().\nFor an example of this, see the Blur Shader recipe.\nRelated Recipes  Shaders: Intro  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/input/mouse_input/",
	"title": "Mouse Input",
	"tags": [],
	"description": "",
	"content": " Problem You want to detect mouse input.\nSolution InputEventMouse is the base class for mouse events. It contains position and global_position properties. Inheriting from it are two classes: InputEventMouseButton and InputEventMouseMotion.\nYou can assign mouse button events in the InputMap, so you can use them with is_action_pressed().\n InputEventMouseButton @GlobalScope.ButtonList contains a list of BUTTON_* constants for each possible button, which will be reported in the event’s button_index property. Note that the scrollwheel also counts as a button - two buttons, to be precise, with both BUTTON_WHEEL_UP and BUTTON_WHEEL_DOWN being separate events.\nUnlike regular buttons, mouse wheel clicks only produce pressed events. There is no concept of a mouse wheel click being \u0026ldquo;released\u0026rdquo;.\n func _unhandled_input(event): if event is InputEventMouseButton: if event.button_index == BUTTON_LEFT: if event.pressed: print(\u0026#34;Left button was clicked at \u0026#34;, event.position) else: print(\u0026#34;Left button was released\u0026#34;) if event.button_index == BUTTON_WHEEL_DOWN: print(\u0026#34;Wheel down\u0026#34;) InputEventMouseMotion These events occur whenever the mouse moves. You can find the distance moved (in screen coordinates) with the relative property.\nHere’s an example using mouse movement to rotate a 3D character:\n# Converts mouse movement (pixels) to rotation (radians). var mouse_sensitivity = 0.002 func _unhandled_input(event): if event is InputEventMouseMotion: rotate_y(-event.relative.x * mouse_sensitivity)"
},
{
	"uri": "http://kidscancode.org/godot_recipes/ai/path_follow/",
	"title": "Path following",
	"tags": [],
	"description": "",
	"content": " Problem You want a character to follow a pre-defined path, such as a guard patrolling or a car following the road.\nSolution There are many ways to approach this problem. In this solution, we\u0026rsquo;ll use Godot\u0026rsquo;s Path2D node (or Path for 3D) as a convenient way to draw paths in the editor.\nYou can add the Path2D as a child of your main scene, your map, or another location that makes sense. Don\u0026rsquo;t make it a child of the patrolling entity, though - or the path will move along with the player!\nDrawing the path After adding the Path2D node, you\u0026rsquo;ll see some new buttons appear above the viewport:\nSelect the \u0026ldquo;Add points\u0026rdquo; button and click to start adding. If you want a closed curve, the \u0026ldquo;Close curve\u0026rdquo; button will connect the last point to the first one.\nUse the \u0026ldquo;Control points\u0026rdquo; mode to adjust the \u0026ldquo;curviness\u0026rdquo; of the line.\nMoving along the path You can use PathFollow2D to automatically move along a path. However, if you\u0026rsquo;re using a kinematic body, this will cause problems with collisions, because you\u0026rsquo;re not using the body\u0026rsquo;s movement methods. For this reason, we\u0026rsquo;ll instead use the path\u0026rsquo;s points as \u0026ldquo;targets\u0026rdquo; for the body to move towards.\nextends KinematicBody2D var move_speed = 100 export (NodePath) var patrol_path var patrol_points var patrol_index = 0 func _ready(): if patrol_path: patrol_points = get_node(patrol_path).curve.get_baked_points() Exporting the patrol_path lets us assign the path node directly in the Inspector. Then, if it\u0026rsquo;s assigned, we can get the points that make up the line in _ready().\nNext, we can use the currently selected point in the path as our target for movement. If we get close enough to it, we advance to the next point in the curve, using wrapi() to loop around to the first point when we reach the end.\nfunc _physics_process(): if !patrol_path: return var target = patrol_points[patrol_index] if position.distance_to(target) \u0026lt; 1: patrol_index = wrapi(patrol_index + 1, 0, patrol_points.size()) target = patrol_points[patrol_index] velocity = (target - position).normalized() * move_speed velocity = move_and_slide(velocity) Related recipes "
},
{
	"uri": "http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_02/",
	"title": "Spawning Circles",
	"tags": [],
	"description": "",
	"content": " In the previous part, we created the Jumper and Circle object that make up the bulk of the game. Now we need to add the progression: a continuous series of spawned circles as long as the player doesn\u0026rsquo;t miss.\nExpanding the Main scene Let\u0026rsquo;s add some more nodes to Main:\n Position2D (\u0026ldquo;StartPosition\u0026rdquo;)\nThis will mark the starting position for the game. Place it near the bottom-center of the screen.\n Camera2D\nThe camera will follow the player as it moves.\nLet\u0026rsquo;s also configure the camera. Set its Offset to (0, -200) - this will ensure we can see more of the world ahead of us. Also set Current to \u0026ldquo;On\u0026rdquo;.\n  Scripting the Main scene Remove the jumper and circle instances we manually created. We\u0026rsquo;ll add them in code moving forward.\nAdd the following to Jumper.gd:\nsignal captured We\u0026rsquo;ll emit this signal when the jumper hits a circle:\nfunc _on_Jumper_area_entered(area): target = area velocity = Vector2.ZERO emit_signal(\u0026#34;captured\u0026#34;, area) And let\u0026rsquo;s change the init() function on the circle to also accept a position:\nfunc init(_position, _radius=radius): position = _position Now let\u0026rsquo;s add a script to the Main scene:\nextends Node var Circle = preload(\u0026#34;res://objects/Circle.tscn\u0026#34;) var Jumper = preload(\u0026#34;res://objects/Jumper.tscn\u0026#34;) var player We need references to both objects so that we can instance them when needed.\nfunc _ready(): randomize() new_game() This is temporary - later we\u0026rsquo;ll have a UI with a start button to call the new game function.\nfunc new_game(): $Camera2D.position = $StartPosition.position player = Jumper.instance() player.position = $StartPosition.position add_child(player) player.connect(\u0026#34;captured\u0026#34;, self, \u0026#34;_on_Jumper_captured\u0026#34;) spawn_circle($StartPosition.position) The new_game() function initializes the game - spawning a player and a circle at the start position, and setting the camera.\nfunc spawn_circle(_position=null): var c = Circle.instance() if !_position: var x = rand_range(-150, 150) var y = rand_range(-500, -400) c.position = player.target.position + Vector2(x, y) add_child(c) c.init(_position) Here\u0026rsquo;s our spawn_circle() function. If it\u0026rsquo;s passed a position, it\u0026rsquo;ll use it, otherwise we pick a random one some distance away from the current target. These are temporary numbers - once we\u0026rsquo;ve got more of the gameplay up and running, we\u0026rsquo;ll see how much they need to be adjusted.\nfunc _on_Jumper_captured(object): $Camera2D.position = object.position call_deferred(\u0026#34;spawn_circle\u0026#34;) Finally, we need the function that processes the jumper\u0026rsquo;s captured signal. We\u0026rsquo;re going to move the camera to the new circle and spawn another. Note that because this function is called during physics processing, we\u0026rsquo;ll get an error if we try and add to the scene tree. Using call_deferred() tells the engine to execute that function as soon as it\u0026rsquo;s safe to do so.\nTry it out. You should be able to jump from circle to circle - how many did you get?\nOne jarring thing is that the camera \u0026ldquo;teleports\u0026rdquo; when it moves to the next circle. We can improve this by enabling Smoothing on the camera. The Smoothing/Speed controls how quickly the camera interpolates to the new position. Try something between 5 and 10.\nAdjustments It\u0026rsquo;s also jarring that when we hit a circle we don\u0026rsquo;t start rotating at the place we hit. Add this to the jumper\u0026rsquo;s _on_Jumper_area_entered() function:\ntarget.get_node(\u0026#34;Pivot\u0026#34;).rotation = (position - target.position).angle() Let\u0026rsquo;s also add this to the circle\u0026rsquo;s init():\nrotation_speed *= pow(-1, randi() % 2) This randomly flips the rotation speed to positive or negative, so we won\u0026rsquo;t always orbit in the same direction.\nTrail Add these nodes to the jumper:\n Node (\u0026ldquo;Trail\u0026rdquo;)  Line2D (\u0026ldquo;Points\u0026rdquo;)   We\u0026rsquo;re going to use this to make a trail that streams out behind the player. Later we\u0026rsquo;ll make it more visually appealing, but for now, let\u0026rsquo;s stick with a simple gradient. In the Fill add a new Gradient, and go from transparent to a color of your choosing:\nNow in the jumper\u0026rsquo;s script, let\u0026rsquo;s add the following:\nonready var trail = $Trail/Points var trail_length = 25 And then in the _physics_process():\nif trail.points.size() \u0026gt; trail_length: trail.remove_point(0) trail.add_point(position) IMAGE/GIF\nCircle animations Finally, we\u0026rsquo;ll add some visuals to the circles. First, we\u0026rsquo;ll add an effect when the player jumps off and the circle disappears. Then, we\u0026rsquo;ll add a capture effect for when we hit a circle.\nAdd an AnimationPlayer node to the Circle.\n\u0026ldquo;Implode\u0026rdquo; animation Add a new animation called \u0026ldquo;implode\u0026rdquo;. Set the length to 0.4 and keyframe two properties of the root Area2D node: Scale at (1, 1) and Modulate at its default ((1, 1, 1, 1)). Then move the scrubber all the way to the end and key the values (0.1, 0.1) and (1, 1, 1, 0) (that\u0026rsquo;s the \u0026ldquo;alpha\u0026rdquo; value of the color).\nCapture animation The capture animation is a little more complex. Duplicate the Sprite and call it SpriteEffect. Set its Visible property off. We\u0026rsquo;re going to animate this second ring zooming in on the main circle.\nHere are the functions to add to the circle script:\nfunc capture(): $AnimationPlayer.play(\u0026#34;capture\u0026#34;) func implode(): if !$AnimationPlayer.is_playing(): $AnimationPlayer.play(\u0026#34;implode\u0026#34;) yield($AnimationPlayer, \u0026#34;animation_finished\u0026#34;) queue_free() And then in Jumper.gd, our jump function becomes:\nfunc jump(): target.implode() target = null velocity = transform.x * jump_speed And in Main, our capture method calls the capture:\nfunc _on_Jumper_captured(object): $Camera2D.position = object.position object.capture() call_deferred(\u0026#34;spawn_circle\u0026#34;) GIF\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/g101/start/101_03/",
	"title": "Nodes: Godot&#39;s building blocks",
	"tags": [],
	"description": "",
	"content": " Nodes are the basic building blocks for creating games in Godot. A node is an object that can represent some kind of specialized game function. A given type of node might display graphics, play an animation, or represent a 3D model of an object. The node also contains a collection of properties, allowing you to customize its behavior. Which nodes you add to your project will depend on what functionality you need. It\u0026rsquo;s a modular system designed to give you flexibility in building your game objects.\nWorking with Nodes Nodes are objects, in the programming sense. They encapsulate data and behavior, and they can inherit properties from other nodes. Rather than use one of the default suggestions, let\u0026rsquo;s click the \u0026ldquo;Add/Create a New Node\u0026rdquo; button in the scene dock.\nHere you\u0026rsquo;ll see the whole hierarchy of node types available in the engine. For example, the nodes with the bluish-purple icons all fall under the \u0026ldquo;Node2D\u0026rdquo; category, meaning they will all have the properties of a Node2D. More about that in a moment.\nThe list is long, and it would be frustrating to have to drill down every time to find the node you need. Instead, you can use the search function to find it using a small number of characters. We\u0026rsquo;re looking for the \u0026ldquo;Sprite\u0026rdquo; node, so I\u0026rsquo;ll just type \u0026ldquo;sp\u0026rdquo; and we\u0026rsquo;ll jump right to it. Click \u0026ldquo;Create\u0026rdquo; to add the node.\nNow we have this Sprite node in our \u0026ldquo;Scene\u0026rdquo; dock. Make sure it\u0026rsquo;s selected, and then look at the Inspector dock on the right side. Over here, you\u0026rsquo;ll see all the properties of whatever node you have selected. Notice that the properties are organized by where they come from. The Sprite node inherits from Node2D, which inherits from CanvasItem, which inherits from the plain old Node.\nOver in the viewport, the sprite doesn\u0026rsquo;t look like much. A sprite\u0026rsquo;s purpose is to display an image, or texture. As you can see in the Inspector, the texture property is currently empty. Fortunately, every new Godot project comes with an image we can use: the Godot icon. Drag the icon from the Filesystem dock and drop it in the texture property.\nIn the Inspector, click to expand the \u0026ldquo;Transform\u0026rdquo; section, and type (50, 50) in the Position property.\nYou can also click and drag the sprite around in the viewport, and you\u0026rsquo;ll see the Position values changing as you move.\nOne important property of nodes is that they can be arranged in a parent-child hierarchy. Make sure you have the Sprite selected and press the add button again. Add another Sprite and also drag the icon into its texture.\nThis new sprite is a child of the first. This means that it\u0026rsquo;s \u0026ldquo;attached\u0026rdquo; to its parent. If the parent sprite moves, so will the child. Click on the child sprite and set its Position to (50, 50). Now click and drag the parent sprite to move it around the screen.\nNotice that the Position of the parent is changing as you move it around. Now check the child: it\u0026rsquo;s still (50, 50). That\u0026rsquo;s because its \u0026ldquo;Transform\u0026rdquo; properties are relative to its parent.\nScenes Grouping nodes together like this is a powerful tool, enabling you to construct complex objects out of node \u0026ldquo;building blocks\u0026rdquo;. For example, a \u0026ldquo;Player\u0026rdquo; node in your game might have many child nodes attached to it: a Sprite for display, an AnimationPlayer to animate it, a Camera to follow it around, and so on.\nA group of nodes arranged in a \u0026ldquo;tree\u0026rdquo; structure like this is called a Scene. In the next part, we\u0026rsquo;ll look at how you can use scenes to organize your game\u0026rsquo;s objects into independent parts that all work together. You\u0026rsquo;ll see this in practice was you work through the examples in later lessons.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/",
	"title": "2D",
	"tags": [],
	"description": "",
	"content": "  2D Tips, tricks, and tutorials on the 2D side of game development.\nIn this section:  Entering/Exiting the screen   Platform character   Screen wrap   Splitscreen multiplayer   TileMap: detecting tiles   Top-down character   Grid-based movement   Car steering   TileMap: using autotile   Moving Platforms   TileMap: animated tiles   Screen Shake   Touchscreen Camera   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/math/transforms/",
	"title": "Transforms",
	"tags": [],
	"description": "",
	"content": " Before reading this, make sure you have an understanding of vectors and how they\u0026rsquo;re used in game development. If you don\u0026rsquo;t, I recommend you read this introduction I wrote for the Godot documentation: Vector Math.\n2D Transforms In 2D space, we use the familiar X-Y coordinate plane. Remember that in Godot, as in most computer graphics applications, the Y axis points downward:\nTo begin, let\u0026rsquo;s consider this spaceship floating in space:\nThe ship is pointing in the same direction as the X axis. If we wanted it to move forward, we could add to its X coordinate and it would move to the left: position += Vector2(10, 0).\nBut what happens when the ship rotates?\nHow do we move the ship forward now? If you remember Trigonometry from school, you might be starting to think about angles, sin and cos and doing something like position += Vector2(10 * cos(angle), 10 * sin(angle)). While this would work, there\u0026rsquo;s a much more convenient way: the Transform.\nLet\u0026rsquo;s look at the rotated ship again, but this time, let\u0026rsquo;s also imagine that the ship has its own X and Y axes that it carries with it, independent of the global axes:\nThese \u0026ldquo;local\u0026rdquo; axes are a part of the transform called the basis.\nKnowing this, we can move the ship forward by moving it along its own X axis and we won\u0026rsquo;t have to worry about angles and trig functions. To do this in Godot, we can use the transform property, which is available to all Node2D derived nodes.\nposition += transform.x * 10 This code says \u0026ldquo;Add the transform\u0026rsquo;s x vector multiplied by 10.\u0026rdquo; Let\u0026rsquo;s break down what that means. The transform contains x and y properties that represent those local axes. They are unit vectors, which means their length is 1. Another term for unit vector is direction vector. They tell us the direction the ship\u0026rsquo;s x axis is pointing. We then multiply by 10 to scale it to a longer distance.\nThe transform property of a node is relative to its parent node. If you need to get the global value, it\u0026rsquo;s available in global_transform.\n In addition to the basis, the transform also contains a component called the origin. The basis represents the body\u0026rsquo;s rotation, while the origin represents the translation, or change in position.\nIn this picture, the blue vector is the transform.origin. It is equal to the object\u0026rsquo;s position vector.\nConverting Between Local and Global Space You can convert coordinates from local to global by applying the transform. To apply a transform, use xform():\nvar global_position = transform.xform(local_position) For convenience, Node2D and Spatial include helper functions for this. Instead of using transform.xform(), you can call to_global():\nvar global_position = to_global(local_position) To convert from global to local coordinates, you can use the opposite (inverse) of the transform with xform_inv().\nLet\u0026rsquo;s use the example of an object in the 2D plane and convert mouse clicks (global space) into coordinates relative to the object:\nextends Sprite func _unhandled_input(event): if event is InputEventMouseButton and event.pressed: if event.button_index == BUTTON_LEFT: printt(event.position, transform.xform_inv(event.position)) As with the previous operation, there are helper functions for this. Instead of using transform.xform_inv(), you can call to_local():\nprintt(event.position, to_local(event.position)) See the Transform2D docs for a list of the available properties and methods.\n3D Transforms In 3D space, the concept of transforms applies in the same way as in 2D. In fact, it becomes even more necessary, as using angles in 3D can lead to a variety of problems, as we\u0026rsquo;ll see in a bit.\n3D nodes inherit from the base node Spatial, which contains the transform information. The 3D transform requires more information than the 2D version. Position is still held in the origin property, but rotation is in a property called basis, which contains three unit vectors representing the body\u0026rsquo;s local X, Y, and Z axes.\nIn the editor, you can see and manipulate the body\u0026rsquo;s local orientation by clicking the \u0026ldquo;Local Space Mode\u0026rdquo; button.  As in 2D, we can use the local axes to move an object forward. In Godot\u0026rsquo;s 3D orientation (Y-up), this means that by default the body\u0026rsquo;s -Z axis is the forward direction:\ntranslation += -transform.basis.z Godot has default vector values defined, for example: Vector3.FORWARD == Vector3(0, 0, -1). See Vector2 and Vector3 for details.\n "
},
{
	"uri": "http://kidscancode.org/godot_recipes/g101/3d/101_3d_03/",
	"title": "Creating a 3D Character",
	"tags": [],
	"description": "",
	"content": " In the last part, we covered how to import 3D objects and how to arrange them in a scene. In this installment, we\u0026rsquo;ll add more objects to the scene, including a user-controlled character.\nBuilding the Scene We\u0026rsquo;re going to continue using the Kenney Platformer Kit we downloaded last time. Select all the \u0026ldquo;block*.glb\u0026rdquo; files and in the \u0026ldquo;Import\u0026rdquo; tab set their \u0026ldquo;Root Type\u0026rdquo; to StaticBody and click \u0026ldquo;Reimport\u0026rdquo;. Select \u0026ldquo;blockLarge.glb\u0026rdquo; and make a new inherited scene. Add a \u0026ldquo;Convex Collision Sibling\u0026rdquo; to the mesh using the menu as you did in the last tutorial. Rename the root node to \u0026ldquo;BlockLarge\u0026rdquo; and save the scene - I recommend making a separate folder for this, as soon you\u0026rsquo;re going to have a bunch of scenes representing the differently shaped platform parts.\nYou can download a starter project with all the block objects already configured and ready to use here: LINK\nOpen the scene from the last tutorial with the \u0026ldquo;Ground\u0026rdquo; plane and the crates. Delete the crates and add an instance of the large block. We want to be able to place these blocks so that they line up. To do this, select \u0026ldquo;Configure Snap\u0026rdquo; from the \u0026ldquo;Transform\u0026rdquo; menu at the top of the Viewport and set Translate Snap to 0.5. Then click on the \u0026ldquo;Snap Mode\u0026rdquo; button (or press the Y key). Now duplicate the block a few times and drag them to arrange.\nIf you like, go ahead and add scenes for some of the other platform blocks and arrange them into a pleasing level. Be creative!\nAdding a Character Now we\u0026rsquo;re going to make a character so we can walk around on the platforms. Open a new scene and start with a KinematicBody named \u0026ldquo;Character\u0026rdquo;. This PhysicsBody node behaves very much like its 2D equivalent (you\u0026rsquo;ve already done the 2D tutorials, right?). It has a move_and_slide() method that we\u0026rsquo;ll use to perform the movement and collision detection. Gravity will be added manually each frame, accelerating in the -Y direction.\nAdd a sphere-shaped MeshInstance and a matching CollisionShape. Remember, you can add a SpatialMaterial to the mesh and set its Albedo property to change the color.\nThe sphere is nice, but it\u0026rsquo;s going to be hard to tell what direction it\u0026rsquo;s facing. Let\u0026rsquo;s add another MeshInstance, this time with a PrismMesh shape. Set its Size to (0.5, 0.5, 0.1) and then its x rotation to -90 degrees. Arrange it so it\u0026rsquo;s pointing along the negative z axis. (You can tell which way is negative because the gizmo arrows point in the positive direction).\nLet\u0026rsquo;s also add a Camera to the scene, so it will follow the player around. Position the camera behind and above the character, angling it down a bit. Click the \u0026ldquo;Preview\u0026rdquo; button to check the camera\u0026rsquo;s view.\nBefore we add a script, open the \u0026ldquo;Project Settings\u0026rdquo; and add the following inputs on the \u0026ldquo;Input Map\u0026rdquo; tab:\n   Input Action Key     move_forward W   move_back S   strafe_right D   strafe_left A   jump Space    Now let\u0026rsquo;s add a script to the body.\nextends KinematicBody var gravity = Vector3.DOWN * 12 # strength of gravity var speed = 4 # movement speed var jump_speed = 6 # jump strength var spin = 0.1 # rotation speed var velocity = Vector3() var jump = false func get_input(): velocity.x = 0 velocity.z = 0 if Input.is_action_pressed(\u0026#34;move_forward\u0026#34;): velocity.z -= speed if Input.is_action_pressed(\u0026#34;move_back\u0026#34;): velocity.z += speed if Input.is_action_pressed(\u0026#34;strafe_right\u0026#34;): velocity.x += speed if Input.is_action_pressed(\u0026#34;strafe_left\u0026#34;): velocity.x -= speed func _physics_process(delta): velocity += gravity * delta get_input() velocity = move_and_slide(velocity, Vector3.UP) The code in _physics_process() is pretty straightforward: add gravity to accelerate in the positive Y direction (downward), call get_input() to check for input, and then use move_and_slide() to move in the direction of the velocity vector.\nIn get_input() we check to see which key is pressed and then move in that direction. Run the program and test:\nThis is all good, but we need to be able to rotate. Let\u0026rsquo;s add a camera to the body and we\u0026rsquo;ll use the mouse to rotate. Place the camera above and behind the character so you have a good view, then add the following code to the character\u0026rsquo;s script:\nfunc _unhandled_input(event): if event is InputEventMouseMotion: if event.relative.x \u0026gt; 0: rotate_y(-lerp(0, spin, event.relative.x/10)) elif event.relative.x \u0026lt; 0: rotate_y(-lerp(0, spin, event.relative.x/10) This will convert any mouse motion in the x direction into a rotation around the y axis. We use lerp() to smooth it out based on how fast you move the mouse.\nRun the scene and confirm that moving the mouse rotates the character:\nHowever, there\u0026rsquo;s a problem. No matter which way we\u0026rsquo;re facing, pressing W moves us along the Z axis. Our movement is using global coordinates, but we need to move in the object\u0026rsquo;s forward direction.\nThe Power of Transforms This is where transforms come in. A transform is a mathematical matrix that contains the object\u0026rsquo;s translation, rotation, and scale information all in one. In Godot it\u0026rsquo;s stored in the Transform data type. The position information is called the transform.origin and the orientation information is in the transform.basis.\nRemember how the 3D gizmo can be set to \u0026ldquo;Local Space Mode\u0026rdquo;? When in this mode, the gizmo\u0026rsquo;s X/Y/Z axes point along the object\u0026rsquo;s axes. This is the basis of the transform. The basis contains three Vector3 objects callsd x, y, and z that represent these directions. We can use this to ensure that pressing the W key will always move us in the object\u0026rsquo;s forward direction.\nChange the get_input() function like so:\nfunc get_input(): var vy = velocity.y velocity = Vector3() if Input.is_action_pressed(\u0026#34;move_forward\u0026#34;): velocity += -transform.basis.z * speed if Input.is_action_pressed(\u0026#34;move_back\u0026#34;): velocity += transform.basis.z * speed if Input.is_action_pressed(\u0026#34;strafe_right\u0026#34;): velocity += transform.basis.x * speed if Input.is_action_pressed(\u0026#34;strafe_left\u0026#34;): velocity += -transform.basis.x * speed velocity.y = vy Now forward and back will always move along the objects\u0026rsquo; Z axis, and the strafe keys along its X.\nJumping Let\u0026rsquo;s add one more movement to the player: jumping.\nAdd these lines to the end of get_input(): jump = false if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): jump = true\nAnd add these to the end of _physics_process(): if jump and is_on_floor(): velocity.y = jump_speed\nWrapping Up In this tutorial you learned how to build a more complex scene, and how to write movement code for a user-controlled character. You also learned about transforms, which are a very important concept in 3D - you\u0026rsquo;re going to be using a lot in the future.\nIn the next part, we\u0026rsquo;ll add some more objects to our 3D world.\nYou can also find a video version of this lesson here:\n    --\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/input/custom_actions/",
	"title": "Adding Input Actions in code",
	"tags": [],
	"description": "",
	"content": " Problem You need to add actions to the InputMap at runtime.\nSolution Typically, you\u0026rsquo;ll add actions to the InputMap via Project Settings, as shown in Recipe: Input Actions. However, you may find yourself needing to add one or more actions directly in a script. TheInputMap singleton has methods to help you do this.\nHere\u0026rsquo;s an example that would add a new action called \u0026ldquo;attack\u0026rdquo; using the space key:\nfunc _ready(): InputMap.add_action(\u0026#34;attack\u0026#34;) var ev = InputEventKey.new() ev.scancode = KEY_SPACE InputMap.action_add_event(\u0026#34;attack\u0026#34;, ev) If you also wanted to add the left mouse button to the same action:\nev = InputEventMouseButton.new() ev.button_index = BUTTON_LEFT InputMap.action_add_event(\u0026#34;jump\u0026#34;, ev) InputMap.add_action() will produce an error if the action already exists. You should check first with InputMap.has_action() before attempting to add a new action.\n Practical Example Let\u0026rsquo;s say you\u0026rsquo;ve made the platform character from Recipe: Platform character and you want to re-use it in another project. If you saved the scene, script, and assets in a single folder, you need only copy that folder to your new project. But you\u0026rsquo;d still need to edit the Input Map in order for the inputs to work.\nInstead, you could add the following code to the player script and be sure that the necessary input actions will be added automatically:\nvar controls = {\u0026#34;walk_right\u0026#34;: [KEY_RIGHT, KEY_D], \u0026#34;walk_left\u0026#34;: [KEY_LEFT, KEY_A], \u0026#34;jump\u0026#34;: [KEY_UP, KEY_W, KEY_SPACE]} func _ready(): add_inputs() func add_inputs(): var ev for action in controls: if not InputMap.has_action(action): InputMap.add_action(action) for key in controls[action]: ev = InputEventKey.new() ev.scancode = key InputMap.action_add_event(action, ev) Related recipes  Input Actions Platform Character  Like video? "
},
{
	"uri": "http://kidscancode.org/godot_recipes/input/mouse_capture/",
	"title": "Capturing the Mouse",
	"tags": [],
	"description": "",
	"content": " Problem You want to hide the mouse cursor and keep the mouse from leaving the game window. This is common in many 3D games (and some 2D ones).\nSolution You can set the mouse state using Input.set_mouse_mode(). There are four possible mouse modes:\n MOUSE_MODE_VISIBLE: The mouse is visible and can move freely into and out of the window. This is the default state.\n MOUSE_MODE_HIDDEN: The mouse cursor is invisible, but the mouse can still move outside the window.\n MOUSE_MODE_CAPTURED: The mouse cursor is hidden and the mouse is unable to leave the game window.\n MOUSE_MODE_CONFINED: The mouse is visible, but cannot leave the game window.\n  \u0026ldquo;Captured\u0026rdquo; is the most commonly used option. You can set the mouse mode at runtime using:\nfunc _ready(): Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED) When the mouse is captured, mouse input events will still be passed as normal. However, you will find there is a problem. If you want to close the game or switch to another window, you can\u0026rsquo;t. For this reason, you will want to also include a way to \u0026ldquo;release\u0026rdquo; the mouse. For example, to release when the player pressed the Escape key:\nfunc _input(event): if event.is_action_pressed(\u0026#34;ui_cancel\u0026#34;): Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE) So that the game doesn\u0026rsquo;t respond to mouse movement when you\u0026rsquo;re in another window, you can test for the capture state in your character controller using:\nif Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED: Once the mouse is released, that leaves the need to re-capture it to continue playing. Assuming you have an event in the Input Map for a mouse click, you can do the following:\nif event.is_action_pressed(\u0026#34;click\u0026#34;): if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE: Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED) Since you may also be using a mouse click to shoot or perform some other action, it\u0026rsquo;s probably a good idea to stop the event from propagating. Add this after setting the mouse mode:\nget_tree().set_input_as_handled()"
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/car_steering/",
	"title": "Car steering",
	"tags": [],
	"description": "",
	"content": " Problem You need to create a 2D top-down car controller.\nSolution When approaching this problem, beginners often wind up creating something that handles nothing like a real car. Some common mistakes you\u0026rsquo;ll find in amateur car games:\n A car doesn\u0026rsquo;t rotate around its center. Put another way, a car\u0026rsquo;s rear wheels don\u0026rsquo;t slide side-to-side. (Unless it\u0026rsquo;s drifting, but we\u0026rsquo;ll talk about that later.) A car can only turn when it\u0026rsquo;s moving - it can\u0026rsquo;t spin in place. A car isn\u0026rsquo;t a train; it\u0026rsquo;s not on rails. Turning at high speeds should involve some sliding (drifting).  There are many approaches to 2D car physics, mainly depending on how \u0026ldquo;realistic\u0026rdquo; you want to be. For this solution, we\u0026rsquo;re going for an \u0026ldquo;arcade\u0026rdquo; level of realism, meaning we\u0026rsquo;ll prioritize action over realism.\nThe method below is based on the algorithm found here: http://engineeringdotnet.blogspot.com/2010/04/simple-2d-car-physics-in-games.html\n The recipe below is broken into 5 parts, each adding a different feature to the car\u0026rsquo;s movement. Feel free to mix-and-match for your needs.\nScene setup Here\u0026rsquo;s the car scene setup:\n- KinematicBody2D - Sprite - CollisionShape2D - Camera2D Add whatever sprite texture you like. For this demo, we\u0026rsquo;ll use art from Kenney\u0026rsquo;s Racing Pack. CapsuleShape2D is a good choice for the collision, so that the car won\u0026rsquo;t have sharp corners to get caught on obstacles.\nWe\u0026rsquo;ll also use four input actions: \u0026ldquo;steer_right\u0026rdquo;, \u0026ldquo;steer_left\u0026rdquo;, \u0026ldquo;accelerate\u0026rdquo;, and \u0026ldquo;brake\u0026rdquo;.\nPart 1: Movement The first step is to code the movement based on the algorithm described above.\nStart with a few variables:\nextends KinematicBody2D var wheel_base = 70 # Distance from front to rear wheel var steering_angle = 15 # Amount that front wheel turns, in degrees var velocity = Vector2.ZERO var steer_angle Set wheelbase to a value that works with your sprite.\nSince we\u0026rsquo;re using keyboard controls, turning is all-or-nothing. If you\u0026rsquo;re using an analog joystick, you can instead vary this value based on the distance the stick moves.\n func _physics_process(delta): get_input() calculate_steering(delta) velocity = move_and_slide(velocity) Each frame, we need to check for input and calculate steering. Then we pass the resulting velocity to move_and_slide(). We\u0026rsquo;ll define those two function next:\nfunc get_input(): var turn = 0 if Input.is_action_pressed(\u0026#34;steer_right\u0026#34;): turn += 1 if Input.is_action_pressed(\u0026#34;steer_left\u0026#34;): turn -= 1 steer_angle = turn * deg2rad(steering_angle) velocity = Vector2.ZERO if Input.is_action_pressed(\u0026#34;accelerate\u0026#34;): velocity = transform.x * 500 Here we check for user input and set the velocity. Note: the speed of 500 is temporary so that we can test movement. We\u0026rsquo;ll address it in the next part.\nfunc calculate_steering(delta): var rear_wheel = position - transform.x * wheel_base / 2.0 var front_wheel = position + transform.x * wheel_base / 2.0 rear_wheel += velocity * delta front_wheel += velocity.rotated(steer_angle) * delta var new_heading = (front_wheel - rear_wheel).normalized() velocity = new_heading * velocity.length() rotation = new_heading.angle() Here is where we implement the algorithm from the link:\n Find the wheel positions. Move the wheels forward. Find the new direction vector. Set the velocity and rotation to the new direction.  Run the project and the car should move and turn. It\u0026rsquo;s still very unnatural though - the car starts and stops instantly. To fix that, we\u0026rsquo;ll add acceleration into the calculation.\nPart 2: Acceleration We\u0026rsquo;ll need another setting variable and one to track the car\u0026rsquo;s overall acceleration:\nvar engine_power = 800 # Forward acceleration force. var acceleration = Vector2.ZERO Change the input code to apply acceleration instead of directly changing the car\u0026rsquo;s velocity.\nfunc get_input(): var turn = 0 if Input.is_action_pressed(\u0026#34;steer_right\u0026#34;): turn += 1 if Input.is_action_pressed(\u0026#34;steer_left\u0026#34;): turn -= 1 steer_angle = turn * steering_angle if Input.is_action_pressed(\u0026#34;accelerate\u0026#34;): acceleration = transform.x * engine_power Once we\u0026rsquo;ve got our acceleration, we can apply it to the velocity like so:\nfunc _physics_process(delta): acceleration = Vector2.ZERO get_input() calculate_steering(delta) velocity += acceleration * delta velocity = move_and_slide(velocity) Now when you run, the car should gradually increase its speed. Careful: we don\u0026rsquo;t have any way to slow down yet!\nPart 3: Friction/drag A car experiences two different deceleration forces: friction and drag.\n Friction is the force applied by the ground. It\u0026rsquo;s high if driving on sand, but low if driving on ice. Friction is proportional to velocity - the faster you\u0026rsquo;re going the stronger the force.\n Drag is the force resulting from wind resistance. It\u0026rsquo;s based on the car\u0026rsquo;s cross-section - a large truck or van experiences more drag than a sleek race car. Drag is proportional to the velocity squared.\n  This means that friction is more significant when moving slowly, but drag becomes dominant at high speeds. We\u0026rsquo;ll add both of these forces to our calculation. As a bonus, the values of these quantities will also give our car a maximum speed - the point where the force from the engine can\u0026rsquo;t overcome the drag force any longer.\nHere are our starting values for these quantities:\nvar friction = -0.9 var drag = -0.0015 As you can see in this graph, these values mean that at a speed of 600 the drag force overcomes the friction force.\nYou can play with the values here to see how they change: https://www.desmos.com/calculator/e4ayu3xkip\nIn _physics_process() we\u0026rsquo;ll call a function to calculate the current friction and apply it to the acceleration force.\nfunc _physics_process(delta): acceleration = Vector2.ZERO get_input() apply_friction() calculate_steering(delta) velocity += acceleration * delta velocity = move_and_slide(velocity) func apply_friction(): if velocity.length() \u0026lt; 5: velocity = Vector2.ZERO var friction_force = velocity * friction var drag_force = velocity * velocity.length() * drag if velocity.length() \u0026lt; 100: friction_force *= 3 acceleration += drag_force + friction_force First, we\u0026rsquo;ll set a minimum speed. This will ensure that the car doesn\u0026rsquo;t keep creeping forward at very low speeds as friction never quite reaches zero.\nThen we calculate the two forces and add them to the total acceleration.\n Part 4: Reverse/Brake We\u0026rsquo;ll need two more settings variables:\nvar braking = -450 var max_speed_reverse = 250 Add the input to get_input():\nif Input.is_action_pressed(\u0026#34;brake\u0026#34;): acceleration = transform.x * braking This is fine for coming to a stop, but we also want to be able to put the car in reverse. Currently, that won\u0026rsquo;t work, because the acceleration is always being applied in the \u0026ldquo;heading\u0026rdquo; direction, which is forward. When we\u0026rsquo;re reversing, we need to accelerate backward.\nfunc calculate_steering(delta): var rear_wheel = position - transform.x * wheel_base / 2.0 var front_wheel = position + transform.x * wheel_base / 2.0 rear_wheel += velocity * delta front_wheel += velocity.rotated(steer_angle) * delta var new_heading = (front_wheel - rear_wheel).normalized() var d = new_heading.dot(velocity.normalized()) if d \u0026gt; 0: velocity = new_heading * velocity.length() if d \u0026lt; 0: velocity = -new_heading * min(velocity.length(), max_speed_reverse) rotation = new_heading.angle() We can find whether we\u0026rsquo;re accelerating forward or backward using the dot product. If the two vectors are aligned, the result will be greater than 0. If the movement is in the opposite direction the car\u0026rsquo;s facing, then the dot product will be less than 0 and we must be moving backward.\n Part 5: Drift/slide We could stop here and you\u0026rsquo;d have a satisfactory driving experience. However, the car still feels like it\u0026rsquo;s \u0026ldquo;on rails\u0026rdquo;. Even at top speed, the turns are perfect, as if the tires have perfect \u0026ldquo;grip\u0026rdquo;.\nAt high speeds (or even low ones, if desired), the turning force should cause the tires to slip and result in a fishtailing/sliding motion.\nvar slip_speed = 400 # Speed where traction is reduced var traction_fast = 0.1 # High-speed traction var traction_slow = 0.7 # Low-speed traction We\u0026rsquo;ll apply these values when calculating the steering. Currently, the velocity is instantly set to the new heading. Instead, we\u0026rsquo;ll use linear_interpolate() to cause it to only \u0026ldquo;turn\u0026rdquo; partway towards the new direction. The \u0026ldquo;traction\u0026rdquo; values will determine how \u0026ldquo;sticky\u0026rdquo; the tires are - a value of 1.0 would represent no sliding.\nfunc calculate_steering(delta): var rear_wheel = position - transform.x * wheel_base / 2.0 var front_wheel = position + transform.x * wheel_base / 2.0 rear_wheel += velocity * delta front_wheel += velocity.rotated(steer_angle) * delta var new_heading = (front_wheel - rear_wheel).normalized() var traction = traction_slow if velocity.length() \u0026gt; slip_speed: traction = traction_fast var d = new_heading.dot(velocity.normalized()) if d \u0026gt; 0: velocity = velocity.linear_interpolate(new_heading * velocity.length(), traction) if d \u0026lt; 0: velocity = -new_heading * min(velocity.length(), max_speed_reverse) rotation = new_heading.angle() Here, we select which traction value to use and apply linear_interpolate() to the velocity.\n Adjustments At this point, we have a large number of settings that control the car\u0026rsquo;s behavior. Adjusting them can drastically change how the car drives. To make experimenting with different values easier, download the project for this recipe below. When you run the game, you\u0026rsquo;ll see a set of sliders you can use to change the car\u0026rsquo;s behavior as you drive (press \u0026lt;Tab\u0026gt; to show/hide the slider panel).\nDownload the project file here: car_steering.zip\n Related recipes  Gamedev Math: Interpolation  Like video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/shaders/greyscale/",
	"title": "Greyscale (monochrome) shader",
	"tags": [],
	"description": "",
	"content": " Problem You want a shader to convert an image to greyscale.\nSolution Let\u0026rsquo;s start with a canvas_item (2D) shader. To convert to greyscale but also preserve pixel contrast, we need to average the pixel\u0026rsquo;s color value. Add the color channels together and divide by 3:\nshader_type canvas_item; void fragment() { COLOR = texture(TEXTURE, UV); float avg = (COLOR.r + COLOR.g + COLOR.b) / 3.0; COLOR.rgb = vec3(avg); } You can apply this to the whole screen by adding a ColorRect (placed in a CanvasLayer to ignore camera movement) and scaling it to cover the screen.\nChange the texture() function to sample the screen instead of the object\u0026rsquo;s pixels:\nCOLOR = texture(SCREEN_TEXTURE, SCREEN_UV); Related Recipes  Shaders: Intro  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/physics/kinematic_friction/",
	"title": "Kinematic Friction",
	"tags": [],
	"description": "",
	"content": " Problem You want to add friction and acceleration to your kinematic character, giving it a smoother feel.\nSolution For most games, we\u0026rsquo;re not necessarily interested in a perfect physics simulation. We want action, responsiveness, and arcade feel. This is why you choose a kinematic body over a rigid one: so that you can control its behavior directly. However, some amount of physics is good - it means an object doesn\u0026rsquo;t instantly change direction or come to a stop.\nBelow is the code for a no-frills kinematic platformer character:\nextends KinematicBody2D var speed = 1200 var jump_speed = -1800 var gravity = 4000 var velocity = Vector2.ZERO func get_input(): velocity.x = 0 if Input.is_action_pressed(\u0026#34;ui_right\u0026#34;): velocity.x += speed if Input.is_action_pressed(\u0026#34;ui_left\u0026#34;): velocity.x -= speed func _physics_process(delta): get_input() velocity.y += gravity * delta velocity = move_and_slide(velocity, Vector2.UP) if Input.is_action_just_pressed(\u0026#34;ui_select\u0026#34;): if is_on_floor(): velocity.y = jump_speed If you run this code, you\u0026rsquo;ll see that the character\u0026rsquo;s x velocity changes instantaneously. To fix this, we\u0026rsquo;ll use lerp() to gradually increase/decrease the velocity.\nUsing lerp lerp(start_value, end_value, amount) lerp(), aka linear interpolate, finds a \u0026ldquo;blended\u0026rdquo; value between two given numbers. See Interpolation for details.\nIn the code below, friction represents how quickly the character comes to a stop, while acceleration determines how quickly it gets up to full speed. Both are values between 0.0 and 1.0.\nReplace the get_input() code with the following:\nvar friction = 0.1 var acceleration = 0.5 func get_input(): var input_dir = 0 if Input.is_action_pressed(\u0026#34;ui_right\u0026#34;): input_dir += 1 if Input.is_action_pressed(\u0026#34;ui_left\u0026#34;): input_dir -= 1 if dir != 0: # accelerate when there\u0026#39;s input velocity.x = lerp(velocity.x, dir * speed, acceleration) else: # slow down when there\u0026#39;s no input velocity.x = lerp(velocity.x, 0, friction) Explanation We\u0026rsquo;re using friction and acceleration as the amount to blend. For acceleration, we want to find a value between the current speed and the maximum, speed. When decelerating, we\u0026rsquo;re ramping the current speed down to 0.\nUsing values of 1.0 would recreate the \u0026ldquo;instant\u0026rdquo; movement we started with.\n Related Recipes  Platform Character  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_03/",
	"title": "Limited circles",
	"tags": [],
	"description": "",
	"content": " In the first two parts, we got the basic gameplay working. Now we\u0026rsquo;re going to start adding some different modes to the circles.\nCircle modes Eventually, we\u0026rsquo;ll have many different modes, but we\u0026rsquo;re going to start with the \u0026ldquo;limited\u0026rdquo; mode: the circle only allows a given number of orbits before disappearing. First, let\u0026rsquo;s add a Label node to show the number of remaining orbits. Type a number (1) in the text field so we can see how it looks.\nIn the Custom Fonts section, add a new DynamicFont, load the Font Data from the assets folder, and set the Size to 64. To align the label, in the \u0026ldquo;Layout\u0026rdquo; menu, choose \u0026ldquo;Center\u0026rdquo;.\nAdd the following new variables at the top of the Circle.gd:\nenum MODES {STATIC, LIMITED} var mode = MODES.STATIC var num_orbits = 3 # Number of orbits until the circle disappears var current_orbits = 0 # Number of orbits the jumper has completed var orbit_start = null # Where the orbits started Next we need a way to set the mode:\nfunc set_mode(_mode): mode = _mode match mode: MODES.STATIC: $Label.hide() MODES.LIMITED: current_orbits = num_orbits $Label.text = str(orbits_left) $Label.show() Right now we have these two modes defined, but later we\u0026rsquo;ll be adding more.\nLet\u0026rsquo;s also add to the init() method a way to pass a mode. The default should be STATIC, but we\u0026rsquo;re going to use LIMITED now so we can test:\nfunc init(_position, _radius=radius, _mode=MODES.LIMITED): set_mode(_mode) The jumper is setting the rotation position when it\u0026rsquo;s captured. Remove the line from Jumper.gd and put it in the circle\u0026rsquo;s capture() method:\nfunc capture(target): jumper = target $AnimationPlayer.play(\u0026#34;capture\u0026#34;) $Pivot.rotation = (jumper.position - position).angle() orbit_start = $Pivot.rotation Note that we\u0026rsquo;re now sending a reference to the jumper, so add var jumper = null at the top, and in the Main.gd script update the call to read object.capture(player).\nNow we can check to see if the jumper has gone full circle, and if so, decrement current_orbits:\nfunc _process(delta): $Pivot.rotation += rotation_speed * delta if mode == MODES.LIMITED and jumper: check_orbits() func check_orbits(): # Check if the jumper completed a full circle if abs($Pivot.rotation - orbit_start) \u0026gt; 2 * PI: current_orbits -= 1 $Label.text = str(current_orbits) if orbits_left \u0026lt;= 0: jumper.die() jumper = null implode() orbit_start = $Pivot.rotation In order for this to work, we need to add a die() method to the jumper:\nfunc die(): target = null queue_free() func _on_VisibilityNotifier2D_screen_exited(): if !target: die() We\u0026rsquo;ve also connected the jumper\u0026rsquo;s VisibilityNotifier2D signal so that we can remove the player when it exits the screen.\nIf we try it out, everything looks good so far:\nCircle effect The last thing we\u0026rsquo;ll do for this part is add a \u0026ldquo;fill\u0026rdquo; effect to the circle to show that the orbits are running out. To begin, we\u0026rsquo;ll use some drawing code from the official docs:\nfunc draw_circle_arc_poly(center, radius, angle_from, angle_to, color): var nb_points = 32 var points_arc = PoolVector2Array() points_arc.push_back(center) var colors = PoolColorArray([color]) for i in range(nb_points + 1): var angle_point = angle_from + i * (angle_to - angle_from) / nb_points - PI/2 points_arc.push_back(center + Vector2(cos(angle_point), sin(angle_point)) * radius) draw_polygon(points_arc, colors) We\u0026rsquo;ll call this function in _draw():\nfunc _draw(): if jumper: var r = ((radius - 50) / num_orbits) * (1 + num_orbits - current_orbits) draw_circle_arc_poly(Vector2.ZERO, r, orbit_start + PI/2, $Pivot.rotation + PI/2, Color(1, 0, 0)) Lastly, add update() to the _physics_process so that it will be called after every call to check_orbits().\nIn the next part we\u0026rsquo;ll start adding some UI.\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/animation/melee_attacks/",
	"title": "Melee attacks",
	"tags": [],
	"description": "",
	"content": " Problem You want to implement a melee attack, such as a sword or punch.\nSolution For this example, we\u0026rsquo;ll assume we have already set up a character with one or more attack animations. To illustrate, we\u0026rsquo;ll use these two attacks:\nWe can detect the sword hitting the target using an Area2D, but we only want that area to be active during the swing. In order for this activation to be in sync with the animation, we\u0026rsquo;ll use the AnimationPlayer to control it.\nAdd an Area2D and CollisionShape2D to the scene. We\u0026rsquo;ll use a rectangle shape for the hitbox and size it so that it covers the sword during the swing frame.\nMove the animation to the first frame and check the Disabled property of the area. Click the keyframe icon to add a track to the animation. Then advance the animation to the frame where the sword is extended, and add another keyframe with Disabled unchecked. Finally, advance to the end of the swing and keyframe Disabled on once more.\nNow connect this new area\u0026rsquo;s area_entered signal (or, depending on how your game is set up, body_entered). For the purposes of this demo, let\u0026rsquo;s assume that any body that can take damage has an Area2D defined and placed in a group called \u0026ldquo;hurtbox\u0026rdquo;.\nfunc _on_SwordHit_area_entered(area): if area.is_in_group(\u0026#34;hurtbox\u0026#34;): area.take_damage() Now you should be able to try it out and see the attack doing damage if the target is inside the sword\u0026rsquo;s hitbox.\nChanging the hitbox size When you have more than one attack animation, the size of the affected area may not be the same. In the above attack animations, the first one is an upward sweeping attack that covers more area. To handle this, we also need to add an animation track for the collision shape\u0026rsquo;s Extents property. Set this and keyframe it at the start of each animation.\nRelated recipes  Top-down character Controlling animation states  Like video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/math/noise/",
	"title": "Noise",
	"tags": [],
	"description": "",
	"content": " Problem You want to use Godot\u0026rsquo;s OpenSimplexNoise to generate noise, noise textures, and other effects.\nSolution Noise, or more specifically gradient noise is a method for generating more natural-looking \u0026ldquo;random\u0026rdquo; patterns. To do this, Godot provides the OpenSimplexNoise class.\nProbably the most well-known gradient noise algorithm is called Perlin noise. Because it and its successor, simplex noise, are protected by patents, Godot uses an algorithm called OpenSimplex to generate noise.\n OpenSimplexNoise works by generating a 3D \u0026ldquo;cloud\u0026rdquo; of points. Each point has a value ranging from -1 to 1. Below are two examples of noise generated by OpenSimplexNoise. In the images, each pixel\u0026rsquo;s white value is mapped to the noise value at that point.\nThe parameters used for configuring OpenSimplexNoise:\n seed - The seed used to generate the random values. Default value: 0. period - Lower values result in higher frequency noise (i.e. more changes in value across the same distance). Default value: 64. octaves - The number of noise layers that contribute to the result. Each successive layer affects the result less (based on the persistence). Default value: 3. lacunarity - The difference in period between octaves. Default value: 2. persistence - The amount that each octave contributes to the noise. Default value: 0.5.  Here\u0026rsquo;s the easiest way to experiment with the effects of the different parameters. Add a Sprite and in its Texture property, choose \u0026ldquo;New NoiseTexture\u0026rdquo;. In that NoiseTexture for Noise choose \u0026ldquo;New OpenSimplexNoise\u0026rdquo;.\nYou\u0026rsquo;ll see a black-and-white texture that\u0026rsquo;s generated based on the noise values. Adjust the values and observe the effect on the image.\nUsing noise values Once you have your noise configured, there are a few ways you can access the values.\n get_noise_2d(x, y) get_noise_3d(x, y, z) get_noise_4d(x, y, z, w)  In each case, the result is a value in the range [-1, 1].\nYou may have noticed there\u0026rsquo;s no get_noise_1d() method. If you need one-dimensional noise, use get_noise_2d() and keep one of the values constant.\n For example, we can use get_noise_3d() to generate a 2d image while varying the third dimension over time to get an animated effect:\nIn this image the color is based on the noise value. Since we don\u0026rsquo;t want negative values for color, we use\nvar value = get_noise_3d(x, y, z) * 0.5 + 0.5\nto modify the results to the range [0, 1]. Then, this value is applied to color using the following formula:\nColor(1.0-value/2.0, 0.5-value/2.0, value/4.0)\nNoise applications Noise can be used for a wide range of applications:\n Procedural terrain generation Visual effects (water, fog, fire, etc)  Download the project file here: kinematic_vs_rigid.zip\n -- Related recipes  Screen Shake  Like video?   -- "
},
{
	"uri": "http://kidscancode.org/godot_recipes/basics/understanding_delta/",
	"title": "Understanding &#39;delta&#39;",
	"tags": [],
	"description": "",
	"content": " Problem The delta or \u0026ldquo;delta time\u0026rdquo; parameter is a frequently-misunderstood concept in game development. In this tutorial, we\u0026rsquo;ll explain how it\u0026rsquo;s used, the importance of frame-rate independent movement, and practical examples of its use in Godot.\nSolution To illustrate the problem, let\u0026rsquo;s consider a Sprite node moving across the screen. If our screen is 600 pixels wide and we want the sprite to take 5 seconds to cross the screen, we can use the following calculation to find the necessary speed:\n600 pixels / 5 seconds = 120 pixels/second  We\u0026rsquo;ll move the sprite every frame using the _process() function. If the game is running at 60 frames per second, we can find the per-frame movement like so:\n120 pixels/second * 1/60 second/frame = 2 pixels/frame  Notice the units are consistent in all the calculations above. Always pay attention to the units in your calculations - it\u0026rsquo;ll save you from making mistakes.\n Here\u0026rsquo;s the necessary code:\nextends Node2D # Desired movement in pixels/frame var movement = Vector2(2, 0) func _process(delta): $Sprite.position += movement Run this code and you\u0026rsquo;ll see the sprite takes 5 seconds to cross the screen.\nMaybe. The trouble begins if there is something else occupying the computer\u0026rsquo;s time. This is called lag and can come from a variety of sources - the cause could be your code or even other applications running on your computer. If this happens, then the length of a frame might increase. As an extreme example, imagine that the frame rate is halved - each frame took 1\u0026frasl;30 instead of 1\u0026frasl;60 of a second. Moving at 2 px/frame, it\u0026rsquo;s now going to take twice as long for the sprite to reach the edge.\nEven small frame rate fluctuations will result in inconsistent movement speed. If this were a bullet or other fast-moving object, we really don\u0026rsquo;t want it slowing down like this. We need the movement to be frame rate independent.\nFixing the frame rate problem When using the _process() function, it automatically includes a parameter called delta that\u0026rsquo;s passed in from the engine (so does _physics_process(), which is used for physics-related code). This is a floating point value representing the length of time since the previous frame. Typically, this will be approximately 1\u0026frasl;60 or 0.0167 seconds.\nWith this information, we can stop thinking about how much to move each frame, and only consider our desired speed in pixels/second (120 from the above calculation).\nMultiplying the engine\u0026rsquo;s delta value by this number will give us how many pixels to move each frame. The number will automatically adjust if the frame time fluctuates.\n# 60 frames/second 120 pixels/second * 1/60 second/frame = 2 pixels/frame # 30 frames/second 120 pixels/second * 1/30 second/frame = 4 pixels/frame  Note that if the frame rate decreases by half (meaning the frame time doubles), then our per-frame movement must also double to keep the desired speed.\nLet\u0026rsquo;s change the code to use this calculation:\nextends Node2D # Desired movement in pixels/second. var movement = Vector2(120, 0) func _process(delta): $Sprite.position += movement * delta Now when running at 30 frames per second, the travel time is consistent:\nIf the frame rate gets very low, the movement is no longer smooth, but the time remains the same.\nUsing delta with motion equations What if your movement is more complex? The concept remains the same. Keep your units in seconds, not frames, and multiply by delta each frame.\nWorking in pixels and seconds is much easier to conceptualize too, since it relates to how we measure these quantities in the real world. \u0026ldquo;Gravity is 100 pixels/second/second, so after the ball falls for 2 seconds, it\u0026rsquo;s traveling at 200 pixels/second.\u0026rdquo; If you\u0026rsquo;re working with frames, then you have to think about acceleration in units of pixels/frame/frame. Go ahead and try - it\u0026rsquo;s not very natural.\n For example, if you are applying a gravity, that\u0026rsquo;s an acceleration - each frame it will increase the velocity by some amount. As in the above example, the velocity then changes the node\u0026rsquo;s position.\nTry adjusting delta and target_fps in the following code to see the effect:\nextends Node2D # Acceleration in pixels/sec/sec. var gravity = Vector2(0, 120) # Acceleration in pixels/frame/frame. var gravity_frame = Vector2(0, .033) # Velocity in pixels/sec or pixels/frame. var velocity = Vector2.ZERO var use_delta = false var target_fps = 60 func _ready(): Engine.target_fps = target_fps func _process(delta): if use_delta: velocity += gravity * delta $Sprite.position += velocity * delta else: velocity += gravity_frame $Sprite.position += velocity Note that we\u0026rsquo;re multiplying by our timestep each frame to update both velocity and position. Any quantity that is updated every frame should be multiplied by delta to ensure it changes independent or frame rate.\nUsing kinematic functions In the above examples, we\u0026rsquo;ve used a Sprite to keep things simple, updating the position every frame. If you\u0026rsquo;re using a kinematic body (in 2D or 3D), you\u0026rsquo;ll instead be using one of its movement methods. Specifically in the case of move_and_slide(), there tends to be some confusion, because it automatically applies delta to the movement vector. This means you won\u0026rsquo;t multiply your velocity by delta . But you will still need to apply it on the acceleration. For example:\n# Sprite movement code: velocity += gravity * delta position += velocity * delta # Kinematic body movement code: velocity += gravity * delta velocity = move_and_slide(velocity) If you don\u0026rsquo;t use delta when applying acceleration to your velocity, then your acceleration will be subject to fluctuations in frame rate. This can have a_much more subtle effect on movement - it will be inconsistent, but much more difficult to diagnose.\nWhen using move_and_slide() you still need to apply delta to any other quantities such as gravity, friction, etc.\n Related Recipes  Using KinematicBody2D  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/3d/",
	"title": "3D",
	"tags": [],
	"description": "",
	"content": "  3D Tips, tricks, and tutorials on the 3D side of game development.\nFor a gentle introduction to working in 3D, see: Intro to 3D\nIn this section:  Camera Gimbal   3D Unit Healthbars   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/g101/3d/101_3d_04/",
	"title": "Using Areas",
	"tags": [],
	"description": "",
	"content": " In the last part, we learned about transforms, a very important concept in 3D that records an object\u0026rsquo;s local orientation in space, and used it to move our KinematicBody character. This time, we\u0026rsquo;re going to look at another type of 3D node: the Area.\nAreas Area nodes are used for detection and influence. They can detect when objects overlap, and when an object enters or exits a region. An Area can also be used to override physics properties, such as gravity or damping, in a region.\nWe\u0026rsquo;re going to use Area to create three types of objects:\n A coin the character can pick up A bullet the character can shoot Spikes that damage the character  To begin, let\u0026rsquo;s set up some collision layers so that we can more easily control what objects the areas can interact with. Open the Project Settings and find the \u0026ldquo;Layer Names/3D Physics\u0026rdquo; section. Name the first three layers \u0026ldquo;environment\u0026rdquo;, \u0026ldquo;player\u0026rdquo;, and \u0026ldquo;pickups\u0026rdquo;.\nCoin Create a new inherited scene from the CoinGold.glb object in the Kenney Platformer Kit (see Part 03). Right-click on the root node, choose \u0026ldquo;Change Type\u0026rdquo;, and pick Area. In the Inspector, set the collision mask and layer so that the coin is in \u0026ldquo;pickups\u0026rdquo; and scans \u0026ldquo;player\u0026rdquo;.\nNow we need a collision shape, so add a CollisionShape node and choose a CylinderShape for it. If you rotate it 90 degrees around z, it will fit the coin shape pretty well.\nAdd a script to the Area and connect its body_entered signal, which we\u0026rsquo;ll use to remove the coin:\nextends Area func _on_Coin_body_entered(body): queue_free() Add a few coins to your scene and see if you can pick them up:\nBullets Make a new scene with an Area2D root, and name it \u0026ldquo;Bullet\u0026rdquo;. Add a MeshInstance, a CollisionShape, and a Timer. I\u0026rsquo;m using a sphere shape for the mesh and collision, scaled to a radius of 0.2 so that it won\u0026rsquo;t be too big compared with the character. The Timer is to give the bullet a time limit. Set its One Shot and Autostart properties both on.\nAdd a script and connect the Timer\u0026rsquo;s timeout signal and the Area\u0026rsquo;s body_entered signal. Then add the following:\nextends Area var speed = 15 var velocity = Vector3() func start(xform): transform = xform velocity = -transform.basis.z * speed func _process(delta): transform.origin += velocity * delta func _on_Timer_timeout(): queue_free() func _on_Bullet_body_entered(body): if body is StaticBody: queue_free() Since we want the bullet to start at a certain location and travel directly ahead of the player, we\u0026rsquo;ll pass the player\u0026rsquo;s transform to start() and use it to orient the bullet and make it move forward (remember in Godot\u0026rsquo;s orientation, \u0026ldquo;forward\u0026rdquo; is along the negative z axis).\nNow we can go to the character scene and add a Position3D node, placing it at the tip of the character\u0026rsquo;s \u0026ldquo;arrow\u0026rdquo; mesh. Name this node \u0026ldquo;Muzzle\u0026rdquo;. Next, add the following code to the character\u0026rsquo;s script:\nvar Bullet = preload(\u0026#34;res://Bullet.tscn\u0026#34;) func _unhandled_input(event): if event.is_action_pressed(\u0026#34;shoot\u0026#34;): var b = Bullet.instance() b.start($Muzzle.global_transform) get_parent().add_child(b) Spikes Finally, we\u0026rsquo;re going to add some danger to the environment. Make in instance of the spikes.glb object and make it an Area like we did with the coin. Add a script and connect the body_entered signal, but this time, we want the object to do something to the character:\nextends Area func _on_Spikes_body_entered(body): if body.has_method(\u0026#34;take_damage\u0026#34;): body.take_damage() Now we need to define how the character reacts to taking \u0026ldquo;damage\u0026rdquo;. Since we haven\u0026rsquo;t really built a health system, we\u0026rsquo;re just going to \u0026ldquo;bounce\u0026rdquo; the character as if it got hurt. We need to add the following to the character script:\nvar can_move = true func take_damage(): velocity *= -1 velocity.y = jump_speed can_move = false yield(get_tree().create_timer(1), \u0026#34;timeout\u0026#34;) can_move = true The purpose of this code is to disable input temporarily so the player will fly backwards from the spikes. If we just tried to set the velocity, it would immediately be overridden by the velocity set by the key inputs. So add this at the beginning of get_input():\nif !can_move: return Add a spike instance to your level and try it out:\nWrapping Up In this tutorial you learned how to use Area nodes to detect and react to 3D bodies.\nIn the next part: a collection of small improvements.\nYou can also find a video version of this lesson here:\n    --\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/shaders/blur/",
	"title": "Blur shader",
	"tags": [],
	"description": "",
	"content": " Problem You want a shader to blur an object or the screen.\nSolution shader_type canvas_item; uniform float blur_amount : hint_range(0, 5); void fragment() { COLOR = textureLod(SCREEN_TEXTURE, SCREEN_UV, blur_amount); } For example, to gradually blur the entire screen, such as for a scene transition effect:\nYou can also animate the blurring:\nextends Node # Add a ColorRect or other Control set to fill the screen # Place it lower in the tree and/or place in CanvasLayer # so it\u0026#39;s on top of the rest of the scene. onready var blur = $Blur var blur_amount = 0 func _process(delta): blur_amount = wrapf(blur_amount + 0.05, 0.0, 5.0) blur.material.set_shader_param(\u0026#34;blur_amount\u0026#34;, blur_amount)  Related Recipes  Shaders: Intro Interacting with Shaders  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/ai/changing_behaviors/",
	"title": "Changing behaviors",
	"tags": [],
	"description": "",
	"content": " Problem You want your AI-controlled entity to switch between different behaviors.\nSolution For this example, we\u0026rsquo;ll assume an enemy with the following behaviors. See the individual recipes for how to make each behavior work.\n Patrol\nThe \u0026ldquo;Patrol\u0026rdquo; state moves along a pre-defined path (or stands still if there\u0026rsquo;s no path assigned). See Recipe: Path following for details.\n Chase\nThe \u0026ldquo;Chase\u0026rdquo; state moves the enemy towards the player. See Recipe: Chasing the player for how to make this behavior.\n Attack\nIn this state, the player is in range of a melee attack, so the enemy stops moving and executes its attack. See Recipe: Melee attacks for how to make melee attacks.\n  These behaviors are states - the enemy can only be in one of these states at a time, and certain events, such as the player getting near, will cause a transition to another state.\nTo determine the state transitions, we have two Area2D nodes on the enemy: an outer one called \u0026ldquo;DetectRadius\u0026rdquo; and an inner called \u0026ldquo;AttackRadius\u0026rdquo;. The player entering or exiting these areas will trigger the related behavior.\nWe\u0026rsquo;ve chosen a rectangular shape for AttackRadius in this example due to the shape of the enemy\u0026rsquo;s attack. Any shape is fine as long as it\u0026rsquo;s smaller than the DetectRadius.\nConnect the body_entered and body_exited signals of both these areas. If you\u0026rsquo;re using collision layers (and you should be), set them so that they can only detect the player (or any other body you want to be chased/attacked).\nNow let\u0026rsquo;s examine the enemy\u0026rsquo;s script:\nextends KinematicBody2D enum states {PATROL, CHASE, ATTACK, DEAD} var state = states.PATROL We start with an enum to give us a way to reference our states by name, and a variable to hold the current state.\n# For setting animations. var anim_state var run_speed = 25 var attacks = [\u0026#34;attack1\u0026#34;, \u0026#34;attack2\u0026#34;] # For path following. export (NodePath) var patrol_path var patrol_points var patrol_index = 0 # Target for chase mode. var player = null var velocity = Vector2(run_speed, 0) The other variables needed for the individual behaviors and animations. See the referenced behavior links above for details.\nfunc _physics_process(delta): choose_action() # Changing the x scale flips the sprite and its attack area. if velocity.x \u0026gt; 0: $Sprite.scale.x = 1 elif velocity.x \u0026lt; 0: $Sprite.scale.x = -1 # If we\u0026#39;re moving, show the run animation. if velocity.length() \u0026gt; 0: anim_state.travel(\u0026#34;run\u0026#34; ) # Show the idle animation when coming to a stop (but not attacking). if anim_state.get_current_node() == \u0026#34;run\u0026#34; and velocity.length() == 0: anim_state.travel(\u0026#34;idle\u0026#34;) velocity = move_and_slide(velocity) We\u0026rsquo;ll handle movement as normal in _physics_process(), calling choose_action() (see below) to decide what the resulting movement will be.\nfunc choose_action(): velocity = Vector2.ZERO var current = anim_state.get_current_node() # If we\u0026#39;re currently attacking, don\u0026#39;t move or change state. if current in attacks: return # Depending on the current state, choose a movement target. var target match state: states.DEAD: set_physics_process(false) # Move along assigned path. states.PATROL: if !patrol_path: return target = patrol_points[patrol_index] if position.distance_to(target) \u0026lt; 1: patrol_index = wrapi(patrol_index + 1, 0, patrol_points.size()) target = patrol_points[patrol_index] velocity = (target - position).normalized() * run_speed # Move towards player. states.CHASE: target = player.position velocity = (target - position).normalized() * run_speed # Make an attack. states.ATTACK: target = player.position if target.x \u0026gt; position.x: $Sprite.scale.x = 1 elif target.x \u0026lt; position.x: $Sprite.scale.x = -1 anim_state.travel(\u0026#34;attack\u0026#34;) In choose_action() we determine the target and move toward it.\nfunc _on_DetectRadius_body_entered(body): state = states.CHASE player = body func _on_DetectRadius_body_exited(body): state = states.PATROL player = null func _on_AttackRadius_body_entered(body): state = states.ATTACK func _on_AttackRadius_body_exited(body): state = states.CHASE Finally, the functions connected to the area signals change the state accordingly.\nExpanding This example is intentionally kept as simplified as possible, while still demonstrating complete behaviors. In a larger project, there would likely be a greater number of behaviors, as well as more complex conditions for deciding which one to apply.\nRelated recipes  Top-down character Spritesheet animation Controlling animation states Path following Chasing the player  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/animation/animation_state_machine/",
	"title": "Controlling animation states",
	"tags": [],
	"description": "",
	"content": " Problem A common situation: you have a large number of animations, and it\u0026rsquo;s becoming difficult to manage transitions between them. Your code has become full of if statements, and every time you change something, it all breaks.\nSolution Use an AnimationTree to create an animation state machine. This will allow us to organize our animations and most importantly, control the transitions between them.\nGetting started For this demo, we\u0026rsquo;ll be using the excellent \u0026ldquo;Adventurer\u0026rdquo; sprite by Elthen. You can get this and lots of other great art at https://elthen.itch.io/.\nWe\u0026rsquo;ll also assume you\u0026rsquo;ve already set up the character\u0026rsquo;s animations using AnimationPlayer. Using the above spritesheet, we have the following animations: \u0026ldquo;idle\u0026rdquo;, \u0026ldquo;run\u0026rdquo;, \u0026ldquo;attack1\u0026rdquo;, \u0026ldquo;attack2\u0026rdquo;, \u0026ldquo;hurt\u0026rdquo;, and \u0026ldquo;die\u0026rdquo;.\nAnimationTree Add an AnimationTree node to the scene. In its Tree Root property, choose \u0026ldquo;New AnimationNodeStateMachine\u0026rdquo;.\nAn AnimationTree is a node that controls animations created in AnimationPlayer. To let it access the existing animations, click \u0026ldquo;Assign\u0026rdquo; in the Anim Player property and select your animation node.\nNow we can begin to set up our state machine in the AnimationTree panel:\nNote the warning. Set the Active property to \u0026ldquo;On\u0026rdquo; in the Inspector.\nRight-click and choose \u0026ldquo;Add Animation\u0026rdquo;. Choose \u0026ldquo;idle\u0026rdquo;, and you\u0026rsquo;ll see a small box representing that animation. Press its \u0026ldquo;Play\u0026rdquo; button and you should see the animation play. Do the same to add boxes for the other animations.\nNow we can add connections. Click the \u0026ldquo;Connect nodes\u0026rdquo; button and drag between nodes to connect them.\nWhen you select an animation, the tree will follow the connected path from the current node to the destination. However, in the configuration above, if you play \u0026ldquo;attack2\u0026rdquo; you won\u0026rsquo;t see \u0026ldquo;attack1\u0026rdquo; along the way. That\u0026rsquo;s because the default \u0026ldquo;switch mode\u0026rdquo; for a connection is \u0026ldquo;Immediate\u0026rdquo;. Click the \u0026ldquo;Move/select\u0026rdquo; button and then click on the connection from \u0026ldquo;attack1\u0026rdquo; to \u0026ldquo;attack2\u0026rdquo;. In the Inspector, change Switch Mode to \u0026ldquo;AtEnd\u0026rdquo;. Do the same with \u0026ldquo;attack2\u0026rdquo; to \u0026ldquo;idle\u0026rdquo;. The connection icon changes from  to .\nNow, with \u0026ldquo;idle\u0026rdquo; playing, if you click \u0026ldquo;attack2\u0026rdquo;, you\u0026rsquo;ll see the two attacks play in sequence.\nBut now the animation stops on \u0026ldquo;attack2\u0026rdquo;. On its connection, set the Auto Advance property to \u0026ldquo;On\u0026rdquo;. This will make the tree go back to \u0026ldquo;idle\u0026rdquo; after playing both animations. Note that the connection icon turns green to show this.\nCalling states in code Here is the full tree for all of the animations:\nWe\u0026rsquo;ve set the \u0026ldquo;die\u0026rdquo; node as the end, so when that one is reached, there will be no further animation. In the bottom-left, we have a double-attack sequence.\nNow let\u0026rsquo;s set up the character to use these animations in a script.\nextends KinematicBody2D var state_machine var run_speed = 80 var attacks = [\u0026#34;attack1\u0026#34;, \u0026#34;attack2\u0026#34;] var velocity = Vector2.ZERO func _ready(): state_machine = $AnimationTree.get(\u0026#34;parameters/playback\u0026#34;) state_machine holds a reference to the state machine, which is an AnimationNodeStateMachinePlayback. To call a specific animation, you use travel(), which will follow the connections to the given animation.\nfunc _physics_process(delta): get_input() velocity = move_and_slide(velocity) func hurt(): state_machine.travel(\u0026#34;hurt\u0026#34;) func die(): state_machine.travel(\u0026#34;die\u0026#34;) set_physics_process(false) Here we have examples of functions we would call if the player is hurt or killed. For the other animations (running, attacking, etc.), we\u0026rsquo;ll need to combine them with our input and movement code. velocity determines whether we should be showing \u0026ldquo;run\u0026rdquo; or \u0026ldquo;idle\u0026rdquo;.\nfunc get_input(): var current = state_machine.get_current_node() velocity = Vector2.ZERO if Input.is_action_just_pressed(\u0026#34;big_attack\u0026#34;): state_machine.travel(\u0026#34;attack1 2\u0026#34;) return if Input.is_action_just_pressed(\u0026#34;attack\u0026#34;): state_machine.travel(attacks[randi() % 2]) return if Input.is_action_pressed(\u0026#34;move_right\u0026#34;): velocity.x += 1 $Sprite.scale.x = 1 if Input.is_action_pressed(\u0026#34;move_left\u0026#34;): velocity.x -= 1 $Sprite.scale.x = -1 if Input.is_action_pressed(\u0026#34;move_up\u0026#34;): velocity.y -= 1 if Input.is_action_pressed(\u0026#34;move_down\u0026#34;): velocity.y += 1 velocity = velocity.normalized() * run_speed if velocity.length() != 0: state_machine.travel(\u0026#34;run\u0026#34;) if velocity.length() == 0: state_machine.travel(\u0026#34;idle\u0026#34;) Note that we\u0026rsquo;re using return after traveling to the attack animations. This is so that we won\u0026rsquo;t instead travel to the \u0026ldquo;run\u0026rdquo; or \u0026ldquo;idle\u0026rdquo; animations further down in the function.\nRelated recipes  Spritesheet animation Top-down character  Like video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/ai/homing_missile/",
	"title": "Homing missile",
	"tags": [],
	"description": "",
	"content": " Problem You need a \u0026ldquo;homing missile\u0026rdquo; - a projectile that will seek a moving target.\nSolution For this example, we\u0026rsquo;ll use an Area2D node for the projectile. Areas are typically good choices for bullets because we need to detect when they contact something. If you also need a bullet that bounces/ricochets, a PhysicsBody type node might be a better choice.\nThe node setup and behavior of the missile is the same you would use for a \u0026ldquo;dumb\u0026rdquo; bullet. If you\u0026rsquo;re creating many bullet types, you can use inheritance to base all your projectiles on the same core setup.\nThe nodes we\u0026rsquo;ll use:\n- Area2D (\u0026#34;Missile\u0026#34;) - Sprite - CollisionShape2D - Timer (\u0026#34;Lifetime\u0026#34;) For the texture, you can use any image you like. Here\u0026rsquo;s an example one:\nSet up the nodes and configure the sprite\u0026rsquo;s texture and the collision shape. Make sure to rotate the Sprite node by 90° so that it\u0026rsquo;s pointing to the right, ensuring it matches the parent\u0026rsquo;s \u0026ldquo;forward\u0026rdquo; direction.\nAdd a script and connect the Area2D\u0026rsquo;s body_entered signal and the Timer\u0026rsquo;s timeout signal.\nHere\u0026rsquo;s the starting script:\nextends Area2D export var speed = 350 var velocity = Vector2.ZERO var acceleration = Vector2.ZERO func start(_transform): global_transform = _transform velocity = transform.x * speed func _physics_process(delta): velocity += acceleration * delta velocity = velocity.clamped(speed) rotation = velocity.angle() position += velocity * delta func _on_Missile_body_entered(body): queue_free() func _on_Lifetime_timeout(): queue_free() This creates a \u0026ldquo;dumb\u0026rdquo; bullet that travels in a straight line when fired. To use this projectile, instance it and call its start() method with the desired Transform2D to set its position and direction.\nSee the related recipes section below for more information.\nTo change the behavior to seek a target, we\u0026rsquo;ll use the acceleration. However, we don\u0026rsquo;t want the missile to \u0026ldquo;turn on a dime\u0026rdquo;, so we\u0026rsquo;ll add a variable to control its \u0026ldquo;steering\u0026rdquo; force. This will give the missile a turning radius that can be adjusted for different behavior. We also need a target variable so that the missile knows what to chase. We\u0026rsquo;ll set that in start() as well:\nexport var steer_force = 50.0 var target = null func start(_transform, _target): # add this line: target = _target To change the missile\u0026rsquo;s direction to move toward the target, it needs to accelerate in that direction (acceleration is change in velocity). The missile \u0026ldquo;wants\u0026rdquo; to move straight towards the target, but its current velocity is pointing in a different direction. Using a little vector math, we can find that difference:\nThe green arrow represents the needed change in velocity (i.e. acceleration). However, if we turn instantly, that will look unnatural, so the \u0026ldquo;steering\u0026rdquo; vector\u0026rsquo;s length needs to be limited. This is the purpose of the steer_force variable.\nThis is the function to calculate that acceleration. Note that if there\u0026rsquo;s no target, there will be no steering, so the missile remains traveling in a straight line.\nfunc seek(): var steer = Vector2.ZERO if target: var desired = (target.position - position).normalized() * speed steer = (desired - velocity).normalized() * steer_force return steer Finally, the resulting steer force must be applied in _physics_process():\nfunc _physics_process(delta): acceleration += seek() velocity += acceleration * delta velocity = velocity.clamped(speed) rotation = velocity.angle() position += velocity * delta Here\u0026rsquo;s an example of the results, with a little extra visual flair such as particle smoke and explosions:\n Here\u0026rsquo;s the full script, including the above effects. See related recipes for details.\nextends Area2D export var speed = 350 export var steer_force = 50.0 var velocity = Vector2.ZERO var acceleration = Vector2.ZERO var target = null func start(_transform, _target): global_transform = _transform rotation += rand_range(-0.09, 0.09) velocity = transform.x * speed target = _target func seek(): var steer = Vector2.ZERO if target: var desired = (target.position - position).normalized() * speed steer = (desired - velocity).normalized() * steer_force return steer func _physics_process(delta): acceleration += seek() velocity += acceleration * delta velocity = velocity.clamped(speed) rotation = velocity.angle() position += velocity * delta func _on_Missile_body_entered(body): explode() func _on_Lifetime_timeout(): explode() func explode(): $Particles2D.emitting = false set_physics_process(false) $AnimationPlayer.play(\u0026#34;explode\u0026#34;) yield($AnimationPlayer, \u0026#34;animation_finished\u0026#34;) queue_free() Related recipes  Spritesheet animation Top-down character  Like video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_04/",
	"title": "Menus",
	"tags": [],
	"description": "",
	"content": " Now that we\u0026rsquo;ve got the basic gameplay, it\u0026rsquo;s time to start working on the UI. We\u0026rsquo;re going to need menu screens for the title, settings, and game over.\nMenu screens The three screens will share a common layout and some functionality, so we\u0026rsquo;ll start with a base scene they can all inherit from. In the new scene, start with a CanvasLayer and name it BaseScreen. Save this scene in the \u0026ldquo;UI\u0026rdquo; folder.\n CanvasLayer (\u0026ldquo;BaseScreen\u0026rdquo;)  MarginContainer VBoxContainer  Label HBoxContainer (\u0026ldquo;Buttons\u0026rdquo;)  Tween   The MarginContainer will ensure that none of our UI elements get too close to the edge of the screen. Set all four of its Custom Constants properties to 20.\nNext is a VBoxContainer to organize the main elements. Set its Custom Constants/Separation to 150.\nThe Label node displays the screen\u0026rsquo;s title. Put \u0026ldquo;Title\u0026rdquo; in its Text field and load the same font resource we used for the circles.\nFinally, add an HBoxContainer named \u0026ldquo;Buttons\u0026rdquo; which will hold the buttons we add to the screens. Set its Separation to 75. Then duplicate the node so that we have another row of buttons.\nThe screen should start offscreen, so set the Offset on the root node to (500, 0). Then add a script to the scene:\nextends CanvasLayer onready var tween = $Tween func appear(): tween.interpolate_property(self, \u0026#34;offset:x\u0026#34;, 500, 0, 0.5, Tween.TRANS_BACK, Tween.EASE_IN_OUT) tween.start() func disappear(): tween.interpolate_property(self, \u0026#34;offset:x\u0026#34;, 0, 500, 0.4, Tween.TRANS_BACK, Tween.EASE_IN_OUT) tween.start() This script sets up the animations we can call to make the screen appear and disappear.\nNow we can make our three inherited scenes. For each, name the root node, change the Label text, and add TextureButtons to the \u0026ldquo;Buttons\u0026rdquo; containers. Use the images from the assets folder for each button\u0026rsquo;s Normal texture. Name each button for its function (\u0026ldquo;Play\u0026rdquo;, \u0026ldquo;Settings\u0026rdquo;, etc.) and add it to the group \u0026ldquo;buttons\u0026rdquo;.\nHere is what the three scenes should look like, using the indicated button names:\nMake one more scene with a Node root named \u0026ldquo;Screens\u0026rdquo; and instance the three screens in it. Add the following script, which will handle scene transitions and state.\nextends Node signal start_game var current_screen = null func _ready(): register_buttons() change_screen($TitleScreen) func register_buttons(): var buttons = get_tree().get_nodes_in_group(\u0026#34;buttons\u0026#34;) for button in buttons: button.connect(\u0026#34;pressed\u0026#34;, self, \u0026#34;_on_button_pressed\u0026#34;, [button.name]) func _on_button_pressed(name): match name: \u0026#34;Home\u0026#34;: change_screen($TitleScreen) \u0026#34;Play\u0026#34;: change_screen(null) yield(get_tree().create_timer(0.5), \u0026#34;timeout\u0026#34;) emit_signal(\u0026#34;start_game\u0026#34;) \u0026#34;Settings\u0026#34;: change_screen($SettingsScreen) func change_screen(new_screen): if current_screen: current_screen.disappear() yield(current_screen.tween, \u0026#34;tween_completed\u0026#34;) current_screen = new_screen if new_screen: current_screen.appear() yield(current_screen.tween, \u0026#34;tween_completed\u0026#34;) func game_over(): change_screen($GameOverScreen) This script connects up all our buttons by linking the pressed signal and passing along the button\u0026rsquo;s name as a parameter. This lets our _on_button_pressed() method decide what each button should do.\nThe change_screen() method handles transition to the selected screen, including the null option for when we don\u0026rsquo;t want to display a screen at all.\nRun it to test out the screen transitions:\nInstance this scene in Main, then connect its start_game signal to the new_game() function in main. Don\u0026rsquo;t forget to remove new_game() from the _ready(). Try running the game and you should be able to start. The last part will be to connect up the game over condition.\nIn the Jumper, add a signal called died and emit that signal in the visibility notifier\u0026rsquo;s method.\nAdd this to the new_game() function:\nplayer.connect(\u0026#34;died\u0026#34;, self, \u0026#34;_on_Jumper_died\u0026#34;) Then add this new function, which will ensure all the circles are removed when the player dies.\nfunc _on_Jumper_died(): get_tree().call_group(\u0026#34;circles\u0026#34;, \u0026#34;implode\u0026#34;) $Screens.game_over() Our menu screens are basic and no-frills, but they\u0026rsquo;re functional. In the next part, we\u0026rsquo;ll continue the UI work with our score counter and other in-game displays.\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/physics/rigidbody_drag_drop/",
	"title": "RigidBody2D: Drag and Drop",
	"tags": [],
	"description": "",
	"content": " Problem You want to pick up and move rigid bodies with the mouse.\nSolution Working with rigid bodies can be tricky. Godot\u0026rsquo;s physics engine controls their movements, and interfering with that can often lead to unexpected results. The key is to make use of the body\u0026rsquo;s mode property. This applies equally well in 2D or 3D.\nBody setup We\u0026rsquo;ll start with our rigid body object, adding a Sprite and CollisionShape2D. You can also add a PhysicsMaterial if you want to set Bounce and Friction properties.\nPlace the body in a group called \u0026ldquo;pickable\u0026rdquo;. We\u0026rsquo;ll use this to allow for multiple instances of the pickable object in the main scene. Attach a script and connect the body\u0026rsquo;s _input_event signal.\nextends RigidBody2D signal clicked var held = false func _input_event(viewport, event, shape_idx): if event is InputEventMouseButton: if event.button_index == BUTTON_LEFT and event.pressed: emit_signal(\u0026#34;clicked\u0026#34;, self) We\u0026rsquo;ll emit a signal when a mouse click is detected. Since there can be many bodies, we\u0026rsquo;ll let the main scene manage whether a body can be dragged or if there\u0026rsquo;s already one in the held state.\nfunc _physics_process(delta): if held: global_transform.origin = get_global_mouse_position() If the body is being dragged, we update its position to follow the mouse.\nfunc pickup(): if held: return mode = RigidBody2D.MODE_STATIC held = true func drop(impulse=Vector2.ZERO): if held: mode = RigidBody2D.MODE_RIGID apply_central_impulse(impulse) held = false Finally, these are the two functions to call when the body is picked up and dropped. Changing the mode to MODE_STATIC removes the body from physics engine processing. Note that other objects can still collide with it. If you don\u0026rsquo;t want that, you can disable the collision_layer and/or collision_mask here as well. Just remember to re-enable them when dropping.\nIn the drop function, when we change back to MODE_RIGID, the body will be asleep. A sleeping body can be awoken by applying an impulse to it (even a zero magnitude impulse is fine). However, by passing in an optional impulse value, we can \u0026ldquo;throw\u0026rdquo; the object on release.\nMain scene Create a main scene with some static body obstacles or a TileMap and instance a few copies of the pickable body.\nHere\u0026rsquo;s the script for the main scene:\nextends Node2D var held_object = null func _ready(): for node in get_tree().get_nodes_in_group(\u0026#34;pickable\u0026#34;): node.connect(\u0026#34;clicked\u0026#34;, self, \u0026#34;_on_pickable_clicked\u0026#34;) func _on_pickable_clicked(object): if !held_object: held_object = object held_object.pickup() Here\u0026rsquo;s where we connect up the signal from the rigid body instances. The connected function sets held_object so that we know something is currently being dragged, and calls the body\u0026rsquo;s pickup() method.\nfunc _unhandled_input(event): if event is InputEventMouseButton and event.button_index == BUTTON_LEFT: if held_object and !event.pressed: held_object.drop(Input.get_last_mouse_speed()) held_object = null Lastly, when the mouse is released during dragging, we can perform the reverse actions. Note the use of get_last_mouse_speed() - be careful with this! You may find yourself launching the rigid bodies at high speeds, especially if the bodies have low mass values. It\u0026rsquo;s probably a good idea to clamp() this to a reasonable value. Experiment to find out what works for you.\n Download the project file here: rigidbody_drag_and_drop.zip\n Related recipes  Using Rigid Bodies Kinematic to Rigid Body Interaction  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/autotile_intro/",
	"title": "TileMap: using autotile",
	"tags": [],
	"description": "",
	"content": " Problem You are using a TileMap, and want to use autotiling to more quickly draw your levels.\nSolution For this demo, we\u0026rsquo;ll be using the following tileset:\nThese tiles are from Kenney\u0026rsquo;s \u0026ldquo;Topdown Shooter\u0026rdquo; art pack, which you can find here:https://kenney.nl/assets/topdown-shooter\n Creating a map from these tiles, if you were adding them one-by-one, would be a tedious process. You would be constantly changing between tiles to line up corners, intersections, and endpoints.\nUsing autotiling, you to draw the walls freely, and the autotiling algorithm selects the correct tiles to make everything line up.\nHere\u0026rsquo;s an example:\nHow autotiling works The tiles we\u0026rsquo;re using are designed for a 3x3 (minimal) tiling. Consider a single tile divided into a 3x3 grid:\nWe can mark the \u0026ldquo;active\u0026rdquo; portions of the tile (i.e. the parts that are not the wall):\nIf we were to do this with each tile, the computer can then make sure that whatever tile is placed adjacent to this one will match up.\nIn a 3x3 grid there are 512 possible combinations (2^9). We can discard most of these, as they don\u0026rsquo;t make sense for making continuous walls. It turns out, to properly cover the wall combinations, you need 48 tiles, which we have in our tileset. We\u0026rsquo;ll be ignoring the 7 tiles in the bottom-right (the ones with the white background).\nMaking the TileSet In your TileMap\u0026rsquo;s Tile Set property, select \u0026ldquo;New TileSet\u0026rdquo; and click on it to open. You\u0026rsquo;ll see the TileSet editor panel open:\nClick the ⊞ button to add a texture, choosing the tile set from above. Then click \u0026ldquo;New Autotile\u0026rdquo; and drag to select the whole image. You will probably need to enable snap and adjust the options. The tiles in this tilest are 64x64 and have a 10 pixel separation. If you\u0026rsquo;re using your own art, you\u0026rsquo;ll need to enter your own values.\nNow that you have selected the set of tiles to make up the autotile group, it\u0026rsquo;s time to set the bitmasks. Click the \u0026ldquo;Bitmask\u0026rdquo; button at the top and start clicking in the tiles. The masked area will appear red. When you\u0026rsquo;re done it should look like this:\nRemember, we\u0026rsquo;re not using the tiles in the lower-right corner.\nLastly, click the \u0026ldquo;Icon\u0026rdquo; button and select a tile you\u0026rsquo;d like to use as the icon for the autotile group. This is the tile that will show under the cursor as you\u0026rsquo;re drawing.\nSwitch back to the TileMap, and you should be able to start drawing. If something is wrong, check your bitmasks and make sure you didn\u0026rsquo;t miss a square on any of the tiles. Compare with the picture above.\nFull TileSet You can also add collision, navigation, or occlusion to your autotile set. If you download the example project below, you\u0026rsquo;ll find a complete tileset with polygons defined on all the tiles.\nDownload the project file here: autotile_intro.zip\n "
},
{
	"uri": "http://kidscancode.org/godot_recipes/input/",
	"title": "Input",
	"tags": [],
	"description": "",
	"content": "  Input Handling input - from keyboard and mouse to game controllers and touchscreens.\nIn this section:  Input Actions   Mouse Input   Adding Input Actions in code   Capturing the Mouse   Customizing the Mouse Cursor   Mouse: Drag-select multiple units   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/animation/",
	"title": "Animation",
	"tags": [],
	"description": "",
	"content": "  Animation Using Godot\u0026rsquo;s animation system.\nIn this section:  Spritesheet animation   Melee attacks   Controlling animation states   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/g101/gdscript/",
	"title": "GDScript",
	"tags": [],
	"description": "",
	"content": "  GDScript GDScript is Godot\u0026rsquo;s built-in scripting language. Its syntax is based on Python, so if you\u0026rsquo;re familiar with that language, you\u0026rsquo;ll feel right at home. In this chapter, we\u0026rsquo;ll introduce the language and get you up to speed with how it works.\nIn this section:  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/g101/3d/",
	"title": "Intro to 3D",
	"tags": [],
	"description": "",
	"content": "  Intro to 3D A gentle introduction to the 3D side of Godot development.\nIn this section:  The 3D Editor   Importing 3D Objects   Creating a 3D Character   Using Areas   Edge Detection \u0026amp; Mouse Capture   Using CSG   First-person Character   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/ui/",
	"title": "UI",
	"tags": [],
	"description": "",
	"content": "  UI Building user interfaces.\nIn this section:  Labels   Containers   Heart Containers: 3 Ways   Object Healthbars   Minimap/radar   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/g101/3d/101_3d_05/",
	"title": "Edge Detection &amp; Mouse Capture",
	"tags": [],
	"description": "",
	"content": " In the last part, we learned how to use Area nodes to detect contact between objects, making coin, bullet, and spike objects for our character to interact with. In this part, we\u0026rsquo;ll look at a few small improvements: capturing the mouse, animating the coins, and detecting edges so our character doesn\u0026rsquo;t fall.\nCapturing the Mouse One issue with our mouse-based controls is that as you move the mouse from side to side, it eventually moves out of the game window and hits the edge of your screen. To solve this, we need to \u0026ldquo;capture\u0026rdquo; the mouse. However, if we do that, we won\u0026rsquo;t be able to close the window or anything else - our mouse will be gone! We\u0026rsquo;ll need a way to release the mouse again.\nFirst, to capture the mouse, add the following to the main scene:\nfunc _ready(): Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED) This takes care of the first part: the mouse will now be captured by our game window. Now we need it to be released when we press the \u0026ldquo;Escape\u0026rdquo; key. Let\u0026rsquo;s put this in the main script as well:\nfunc _input(event): if event.is_action_pressed(\u0026#34;ui_cancel\u0026#34;): Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE) Run the game and try it out.\nLet\u0026rsquo;s also ignore mouse motion when it\u0026rsquo;s not captured. In the character script, change this line in _unhandled_input():\nif event is InputEventMouseMotion and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED: Now we have another issue: once you\u0026rsquo;ve pressed \u0026ldquo;Escape\u0026rdquo;, we don\u0026rsquo;t have a way to go back to being captured. Let\u0026rsquo;s do that if we click on the window:\nfunc _input(event): if event.is_action_pressed(\u0026#34;ui_cancel\u0026#34;): Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE) if event.is_action_pressed(\u0026#34;shoot\u0026#34;): if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE: Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED) This works OK, but when we click to recapture the mouse, we also fire a bullet, since the mouse click does that as well. We can solve this by marking the input as \u0026ldquo;handled\u0026rdquo;, so that Godot won\u0026rsquo;t send it on to any other nodes:\nif event.is_action_pressed(\u0026#34;shoot\u0026#34;): if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE: Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED) get_tree().set_input_as_handled() Now that first click capturing the mouse won\u0026rsquo;t also fire a bullet.\nAnimated Coins Now we\u0026rsquo;re going to make the coins from the last part a bit more dynamic and appealing. Open Coin.tscn and add an AnimationPlayer to the scene.\nClick the \u0026ldquo;Animation\u0026rdquo; button and select \u0026ldquo;New\u0026rdquo; to create a new animation called \u0026ldquo;bounce\u0026rdquo;. A duration of 1 second is fine, but make sure to enable looping.\nWe\u0026rsquo;re going to animate two properties of the coin: position (on the Y axis, up and down) and rotation. Ensure the scrubber is at time 0 and add a keyframe for both Translation and Rotation Degrees.\nMove the scrubber to the 0.5 second mark, change the Y component of the translation to 0.3, and click the keyframe button. Then move the scrubber all the way to 1.0 and keyframe the rotation at 180 degrees in Y.\nPress \u0026ldquo;Play\u0026rdquo; to see how your animation looks. Try clicking on the individual translation keyframes and adjusting the Easing value.\nFinally, click the \u0026ldquo;Autoplay\u0026rdquo; button to ensure the animation will automatically start when the game is run.\nEdge Detection Finally, let\u0026rsquo;s see if we can keep our character from running off a cliff and falling to its death.\nStart by adding a RayCast node to the player. It appears as a thin blue line. By default, its Cast To property is set to (0, -1, 0), which is pointing down. This is good, but we also need to move it forward so that it\u0026rsquo;s pointing down at the front of the character:\nAlso, make sure to check the Enabled property, or the RayCast won\u0026rsquo;t work.\nNow, in our character script, we need to check that when moving forward, if the RayCast is colliding, it\u0026rsquo;s safe to move.\nRight now, we have the following:\nif Input.is_action_pressed(\u0026#34;move_forward\u0026#34;): velocity += -transform.basis.z * speed Let\u0026rsquo;s try only adding to the velocity if the ray is colliding:\nif Input.is_action_pressed(\u0026#34;move_forward\u0026#34;) and $RayCast.is_colliding(): velocity += -transform.basis.z * speed Try it out. When you run up to an edge, you\u0026rsquo;ll stop. But wait - have you tried jumping forward? Our forward movement is now canceled when we\u0026rsquo;re in the air! Back to the drawing board.\nNow we need to also check if we\u0026rsquo;re on the ground, so that if we walk forward and the ray stops colliding, we do nothing. Otherwise, we move as normal:\nif Input.is_action_pressed(\u0026#34;move_forward\u0026#34;): if is_on_floor() and !$RayCast.is_colliding(): pass else: velocity += -transform.basis.z * speed You may be wondering why I wrote it this way. Keep reading, there\u0026rsquo;s a reason!\n This works, but something feels off about the code. We have a conditional statement that does nothing. Surely we can simplify this. We can, with a little bit of Boolean Algebra.\nOur conditional statement is essentially this:\nif A: do_nothing else: do_something Which is equivalent to:\nif not A: do_something So what we really need to do is convert our conditional statement to:\nif !(is_on_floor() and !$RayCast.is_colliding()) This works, but it\u0026rsquo;s hard to read. Can it be simplified? It can, using a Boolean Algebra method called \u0026ldquo;De Morgan\u0026rsquo;s Law\u0026rdquo;. De Morgan\u0026rsquo;s Law states that\nnot (A and B) = not A or not B So we can apply that here and we get the following:\nif Input.is_action_pressed(\u0026#34;move_forward\u0026#34;): if !is_on_floor() or $RayCast.is_colliding(): velocity += -transform.basis.z * speed In English:\n\u0026ldquo;If we\u0026rsquo;re not on the floor or there is floor in front of us, move forward.\u0026rdquo;\nThis is a very simplistic implementation - you can still walk sideways or backwards off the edge, for example. Feel free to take this idea and run with it to make improvements. Some games let you fall if you move off the edge slowly, but stop you if you\u0026rsquo;re moving fast.\nWrapping Up In this tutorial, we added a few small improvements to the game. Capturing the mouse is useful in many types of 3D games (first-person, for example), and RayCasts have a wide range of uses - we only touched on one here. The animation we added was very small, but a good start - we\u0026rsquo;ll be using them for many things as we move forward.\nIn the next part: Using Constructed Solid Geometry (CSG).\nYou can also find a video version of this lesson here:    --\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/3d/healthbars/",
	"title": "3D Unit Healthbars",
	"tags": [],
	"description": "",
	"content": " Problem You want a floating \u0026ldquo;healthbar\u0026rdquo; for your 3D game objects (mobs, characters, etc.).\nSolution For this solution, we\u0026rsquo;re going to re-use a 2D healthbar based on a TextureProgress node. It\u0026rsquo;s already set up with textures and code for updating the value and color. If you already have something similar, feel free to use it here. In the example, we\u0026rsquo;ll name this scene \u0026ldquo;Healthbar2D\u0026rdquo;.\nIf you need some assets, here are the three images used in the bar:\nRe-using existing objects can save you a lot of time. Don\u0026rsquo;t re-invent the wheel everytime you need a healthbar, camera, or other common object.\n Project setup We\u0026rsquo;ll start with a KinematicBody mob. It\u0026rsquo;s programmed to spawn and travel in a straight line. It also has the following code to handle damage:\nfunc _on_Mob_input_event(camera, event, click_position, click_normal, shape_idx): if event is InputEventMouseButton: if event.button_index == BUTTON_LEFT and event.pressed: health -= 1 if health \u0026lt;= 0: queue_free() Clicking on a unit deals one damage. Do ten damage, and the unit is destroyed. Now we need a visual representation of that using our 2D bar.\n2D in 3D You can display a 2D image in 3D using a Sprite3D. Add one to a new scene and name it \u0026ldquo;Healthbar3D\u0026rdquo;. First, we\u0026rsquo;ll get it configured and sized, so set the Texture to the green bar image.\nThe Sprite3D acts like any other 3D object - as we pan the camera around, our perspective on it changes. However, we want the healthbar to always \u0026ldquo;face\u0026rdquo; toward the camera so that we can see it.\nIn the Inspector, under GeometryInstance/Material Override, add a new SpatialMaterial. Set the following properties in the SpatialMaterial:\n Flags/Transparent: On Flags/Unshaded: On Parameters/Billboard Mode: Enabled  Now try moving the camera to confirm that the texture is always facing you.\nAdd an instance of this scene to the Mob scene and position the bar above the mob\u0026rsquo;s body.\nViewport texture We don\u0026rsquo;t want the Sprite3D to show a static texture - we want it to display the 2D TextureProgress. We can do that using a Viewport node, which can export a texture.\nAdd a Viewport as a child of the Sprite3D. In the Inspector set these properties:\n Transparent Bg: On Rendering/Usage: 2D Render Target/V Flip: On  We also need to set the size of the Viewport to match the size of the healthbar texture, which is (200, 26).\nInstance the HealthBar2D as a child of the Viewport. Your scene should look like this:\nIf the Viewport were not a child of the Sprite3D, we could set it as the sprite\u0026rsquo;s texture directly in the Inspector. Since it\u0026rsquo;s a child, it won\u0026rsquo;t be ready at the right time, so we\u0026rsquo;ll need to set it in a script attached to the Sprite3D:\nextends Sprite3D func _ready(): texture = $Viewport.get_texture() Connecting it all together In the mob\u0026rsquo;s _on_Mob_input_event() method, add the following after reducing the health:\n$HealthBar3D.update(health, max_health) Add the following to HealthBar3D.gd:\nonready var bar = $Viewport/HealthBar2D func update(value, full): bar.update_bar(value, full) This calls the update method that already exists on the 2D bar, setting the progress bar\u0026rsquo;s value and selecting the bar color:\nfunc update_bar(amount, full): texture_progress = bar_green if amount \u0026lt; 0.75 * full: texture_progress = bar_yellow if value \u0026lt; 0.45 * full: texture_progress = bar_red value = amount Click on the mobs to see the health bars change.\nDownload the project file here: 3d_labels.zip\n Wrapping up You can use this technique to display any other Control nodes, such as Label, VideoPlayer, etc. You can even use the Viewport to \u0026ldquo;project\u0026rdquo; an entire 2D game in 3D space.\nRelated Recipes  Object Healthbars (2D)  Like video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/input/custom_mouse_cursor/",
	"title": "Customizing the Mouse Cursor",
	"tags": [],
	"description": "",
	"content": " Problem You want to use a custom mouse cursor.\nSolution Setting the mouse cursor is done with Input.set_custom_mouse_cursor(). All you need is a texture to use. The texture must be no larger than 256x256 pixels in size.\nFor example, to use the following image:\nAnd set its hotspot to the center:\nextends Node2D func _ready(): Input.set_custom_mouse_cursor(cursor_image, Input.CURSOR_ARROW, Vector2(64, 64)) The second parameter sets which system cursor to replace. See the Input docs for the full list.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/ui/heart_containers_3/",
	"title": "Heart Containers: 3 Ways",
	"tags": [],
	"description": "",
	"content": " Problem You need to display a heart container bar (or other icon-based bar).\nSolution A common way of displaying the player\u0026rsquo;s health is via a series of icons (typically hearts) that disappear as the player takes damage.\nIn this recipe, we\u0026rsquo;re going to explore three ways of displaying this information, which I\u0026rsquo;m labeling \u0026ldquo;simple\u0026rdquo;, \u0026ldquo;empty\u0026rdquo;, and \u0026ldquo;partial\u0026rdquo;:\nThis image shows what the bar displays when the player has 3 health.\n simple: Only the hearts are displayed. empty: Empty heart containers are displayed. partial: The player can have partially filled containers.  Setting up the bar The heart images I\u0026rsquo;m using are 53x45. You can get them here:\nKenney.nl: Platformer Art Deluxe\nIdeally, your heart bar will be easy to drop into your overall HUD/UI. It therefore makes sense to make it a separate scene. We\u0026rsquo;ll start with an HBoxContainer which will keep things aligned. Set the Custom Constants/Separation to 5.\nAdd a TextureRect child. Drag your heart texture into the Texture property and set the Stretch Mode to \u0026ldquo;Keep\u0026rdquo;. Name the node \u0026ldquo;1\u0026rdquo; and then press \u0026ldquo;Ctrl-D\u0026rdquo; to duplicate the node for as many hearts as you need (5 in this example). Your node setup should look like this:\nAdding a script The script below will cover all three bar configurations for flexibility. If you only need one in your game, you can remove the code relating to the other modes.\nTo begin, we\u0026rsquo;re going to load the textures we need and define our three bar modes:\nextends HBoxContainer enum MODES {simple, empty, partial} var heart_full = preload(\u0026#34;res://assets/hud_heartFull.png\u0026#34;) var heart_empty = preload(\u0026#34;res://assets/hud_heartEmpty.png\u0026#34;) var heart_half = preload(\u0026#34;res://assets/hud_heartHalf.png\u0026#34;) export (MODES) var mode = MODES.simple func update_health(value): match mode: MODES.simple: update_simple(value) MODES.empty: update_empty(value) MODES.partial: update_partial(value) Calling update_health() on the bar will cause it to display the passed value, based on the selected mode.\nWe\u0026rsquo;re not going to do any bounds checking on the value input. There are many ways you may have health implemented in your game, and so that\u0026rsquo;s left to you.\n First, the update_simple() method. Here, we loop through the heart containers and set the visibility of each TextureRect:\nfunc update_simple(value): for i in get_child_count(): get_child(i).visible = value \u0026gt; i update_empty() is very similar, except instead of hiding the icon, we change its texture to the empty container:\nfunc update_empty(value): for i in get_child_count(): if value \u0026gt; i: get_child(i).texture = heart_full else: get_child(i).texture = heart_empty Finally, for the partially filled containers, we have a third texture and twice the number of possible values:\nfunc update_partial(value): for i in get_child_count(): if value \u0026gt; i * 2 + 1: get_child(i).texture = heart_full elif value \u0026gt; i * 2: get_child(i).texture = heart_half else: get_child(i).texture = heart_empty Here\u0026rsquo;s an example using each of the bar modes:\nWrapping up Use this heart bar setup as a basis for your own HUD. This technique can be expanded to support a wide variety of information displays.\nDownload the project file here: heart_bars.zip\n Related recipes  UI: Containers  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/physics/kinematic_to_rigidbody/",
	"title": "Kinematic to Rigid Body Interaction",
	"tags": [],
	"description": "",
	"content": " Problem You want your kinematic character to interact with rigid bodies.\nSolution This recipe applies equally well in both 2D and 3D nodes.\n By default, a kinematic body moved with move_and_slide() or move_and_collide() will push any rigid bodies it collides with. This interaction ignores the rigid body\u0026rsquo;s physics properties due to the kinematic move function\u0026rsquo;s infinite_inertia parameter.\nIn some cases, this might be all you need. However, if you want to avoid \u0026ldquo;glitches\u0026rdquo; such as body overlap, tunneling, and other unrealistic behavior, you\u0026rsquo;ll need to add some code for the interactions.\nFor this example, we\u0026rsquo;ll use the 2D character described in the Platform character recipe.\nThe most commonly used movement method for kinematic bodies is move_and_slide(). In the example code, the movement happens on this line:\nvelocity = move_and_slide(velocity, Vector2.UP) This causes the body to move in the given direction and slide along obstacles when colliding, as well as using the floor_normal parameter to determine what surfaces should count as a \u0026ldquo;floor\u0026rdquo;. move_and_slide() also contains additional parameters:\nmove_and_slide ( Vector2 linear_velocity, Vector2 floor_normal=Vector2( 0, 0 ), bool stop_on_slope=false, int max_slides=4, float floor_max_angle=0.785398, bool infinite_inertia=true ) It\u0026rsquo;s that last one that needs to be changed. Since GDScript doesn\u0026rsquo;t have named parameters, this means we have to pass all of them, but we can keep them at their default values:\nvelocity = move_and_slide(velocity, Vector2.UP, false, 4, PI/4, false) Now if you try to move, you\u0026rsquo;ll see that the kinematic body just stops on collision. Now it can\u0026rsquo;t push the rigid body at all.\nTo give the colliding body a \u0026ldquo;push\u0026rdquo; we\u0026rsquo;ll need to apply an impulse. An impulse is an instantaneous \u0026ldquo;kick\u0026rdquo; - think a bat hitting a ball. This is as opposed to a force, which is a continuous \u0026ldquo;push\u0026rdquo; on an object.\n# This represents the player\u0026#39;s inertia. export (int, 0, 200) var push = 100 func _physics_process(delta): # after calling move_and_slide() for index in get_slide_count(): var collision = get_slide_collision(index) if collision.collider.is_in_group(\u0026#34;bodies\u0026#34;): collision.collider.apply_central_impulse(-collision.normal * push) The collision normal points out of the rigid body, so we reverse it to point away from the character and apply the push factor. Now pushing works again, but it won\u0026rsquo;t force the rigid bodies through walls:\nYou can also scale the force of the impulse based on the character\u0026rsquo;s speed:\ncollision.collider.apply_central_impulse(-collision.normal * velocity.length() * push_factor) # Depending on your character\u0026#39;s movement speed, adjust push_factor to # something between 0 and 1. Download the project file here: kinematic_vs_rigid.zip\n Related recipes  Platform character  Like video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/games/circle_jump/",
	"title": "Mobile Game: Circle Jump",
	"tags": [],
	"description": "",
	"content": "  Circle Jump An end-to-end game development series. In this series, we build a one-touch mobile game called \u0026ldquo;Circle Jump\u0026rdquo;. Here\u0026rsquo;s what the game looks like:\nIn each part of the series, we\u0026rsquo;ll add features and fix bugs, explaining the process along the way.\nWhen complete, the game will be available on the following platforms:\n Android: coming soon iOS: coming soon Web: coming soon  You can also download it for the following desktop platforms:\n Windows: coming soon Linux: coming soon MacOS: coming soon  All source code for the game is available on GitHub.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/moving_platforms/",
	"title": "Moving Platforms",
	"tags": [],
	"description": "",
	"content": " Problem You need moving platforms in your 2D platformer.\nSolution There are several ways to approach this problem. In this recipe, we\u0026rsquo;ll use KinematicBody2Ds for our platforms and move them with AnimationPlayer. This allows for a variety of movement styles while minimizing the amount of code we need to write.\nSetting up We\u0026rsquo;ll start with a basic platformer setup using the Platform character recipe. We will need to make one small modification from that recipe: using move_and_slide_with_snap() for the movement.\nHere is the updated code:\nfunc _physics_process(delta): get_input() velocity.y += gravity * delta var snap = Vector2.DOWN * 16 if is_on_floor() else Vector2.ZERO velocity = move_and_slide_with_snap(velocity, snap, Vector2.UP) if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): if is_on_floor(): velocity.y = jump_speed With this code, we\u0026rsquo;ll still get the same behavior with jumping and sliding, but the snap value will ensure that the character \u0026ldquo;sticks\u0026rdquo; to the platform even if it moves. See the KinematicBody2D docs for more information on how the snap parameter works.\nCreating the platform The platform scene contains the following nodes:\nThe Node2D parent is there to act as the \u0026ldquo;anchor\u0026rdquo; or start point for the platform. We\u0026rsquo;ll animate the platform\u0026rsquo;s position relative to this parent node.\nSet up the Sprite\u0026rsquo;s Texture and the collision shape appropriately. In the KinematicBody2D, set the Sync to Physics property \u0026ldquo;On\u0026rdquo;. Since we\u0026rsquo;re not moving the body in code, this ensures that it\u0026rsquo;s moved during the physics step. You\u0026rsquo;ll also need to set the Process Mode property of the AnimationPlayer to \u0026ldquo;Physics\u0026rdquo;.\nTo move the platform, create an animation in the AnimationPlayer that animates the body\u0026rsquo;s position property. For example, here\u0026rsquo;s one animating the platform horizontally in a 4 second loop:\nYou\u0026rsquo;re done! Instance some platforms in your level/world and try them out:\n Download the project file here: moving_platforms.zip\n Related recipes  Platform character  Like video? Coming soon   --\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_05/",
	"title": "Score and HUD",
	"tags": [],
	"description": "",
	"content": " In the last part, we added UI in the form of menus to start and configure the game. We also need a UI to display in-game information such as score.\nHUD scene Add a new scene with a CanvasLayer root to be our HUD. Give it two children: a MarginContainer named \u0026ldquo;ScoreBox\u0026rdquo; and a `Label\u0026rdquo; named \u0026ldquo;Message\u0026rdquo;.\nYour scene tree should look like this:\nSet the layout of the ScoreBox to \u0026ldquo;Bottom Wide\u0026rdquo; and the Custom Constants all to 20. Add an HBoxContainer child and under that two Label nodes. Name the second label \u0026ldquo;Score\u0026rdquo; and put 100 in its Text property. Set the HBoxContainer\u0026rsquo;s Alignment to \u0026ldquo;End\u0026rdquo;.\nAdd the same DynamicFont resource to both labels, but choose \u0026ldquo;Make Unique\u0026rdquo; on the first label and set its size to 32. Set its Text property to \u0026ldquo;Score\u0026rdquo;. In its _Size Flags/Vertical, set \u0026ldquo;Fill\u0026rdquo;. Your layout should look like this:\nNow for the Message node load the font and set Text to \u0026ldquo;Message\u0026rdquo; so we\u0026rsquo;ll have something to see. Also choose \u0026ldquo;Make Unique\u0026rdquo; on the font resource (you\u0026rsquo;ll see why in the next section). Set Align and Valign to \u0026ldquo;Center\u0026rdquo; and Clip Text to \u0026ldquo;On\u0026rdquo;. For layout, choose \u0026ldquo;Center Wide\u0026rdquo;. Also, set Grow Direction/Vertical to \u0026ldquo;Both\u0026rdquo;.\nMessage animation This message will show information during gameplay (level up, bonuses, etc). We want it to be animated - to appear and then fade out. Add an AnimationPlayer to the scene.\nWe\u0026rsquo;ll make two animations: one to set the initial values, and one to animate the message display. Add the first animation, \u0026ldquo;init\u0026rdquo; and click the \u0026ldquo;Autoplay on Load\u0026rdquo; button. Set the length to 0.1.\nAdd a keyframe at time 0 for the Font/Size (64), and one for the Visible set to \u0026ldquo;Off\u0026rdquo;.\nAdd the second animation, \u0026ldquo;show_message\u0026rdquo;. Set its length to 0.75 and keyframe Visibility to \u0026ldquo;On\u0026rdquo;.\nNext, we\u0026rsquo;ll keyframe the Font/Size from 64 at time 0 and 200 at the end. Set the track\u0026rsquo;s Update Mode to \u0026ldquo;Continuous\u0026rdquo;.\nWe also want it to fade out as it grows, so keyframe the Modulate alpha value from 255 to 0.\nHeres\u0026rsquo; what the animation settings should look like:\nAnd the animation when it plays:\nHUD Script Now let\u0026rsquo;s add a script to the scene, with methods to update the displays:\nextends CanvasLayer func show_message(text): $Message.text = text $AnimationPlayer.play(\u0026#34;show_message\u0026#34;) func hide(): $ScoreBox.hide() func show(): $ScoreBox.show() func update_score(value): $ScoreBox/HBoxContainer/Score.text = str(value) Instance the HUD in the main scene, and add $HUD.hide() to the _ready() and _on_Jumper_died() functions. In new_game() we need to show the hud and display a message:\n$HUD.show() $HUD.show_message(\u0026#34;Go!\u0026#34;) To add the score, create a score variable and set it to 0 in new_game(). In _on_Jumper_captured() increment it by one. Make sure to call $HUD.update_score(score) after each of these.\nIn the next part, we\u0026rsquo;ll add sound and color to the game!\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/tilemap_animation/",
	"title": "TileMap: animated tiles",
	"tags": [],
	"description": "",
	"content": " Problem You\u0026rsquo;d like to use animated tiles in your TileMap.\nSolution The most straightforward way to approach this problem is to use the AnimatedTexture resource.\nCreating an AnimatedTexture For this example, we\u0026rsquo;ll use the following water tiles:\nDownload these images: water.zip\nUnzip the images into your project folder. In the Inspector, click the \u0026ldquo;Create a new resource\u0026rdquo; button:\nChoose AnimatedTexture and set the Frames property to 5. For each frame, drag the corresponding image to its Texture property.\nYou can adjust the overall animation\u0026rsquo;s speed with the Fps property, as well as each individual frame\u0026rsquo;s Delay Sec.\nClick the \u0026ldquo;Save\u0026rdquo; button to save the resource. Give it a name such as water_anim.tres.\nUsing AnimatedTexture in a TileMap Now that the AnimatedTexture is saved, it can be used in a TileSet. Open a new or existing TileMap and select its Tile Set property. Click the button to add a new texture to the TileSet:\nSelect the newly added texture and click \u0026ldquo;New Single Tile\u0026rdquo;. Draw a box around the texture (use \u0026ldquo;Enable Snap\u0026rdquo; to make this easier).\nNow you can select the tile in your TileMap and draw with it just like any other tile.\nYou can download a complete project of this example: animated_tiles.zip\nRelated Recipes  TileMap: using autotile  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/math/",
	"title": "Gamedev Math",
	"tags": [],
	"description": "",
	"content": "  Gamedev Math Math is a big part of game development. Some of it you may remember from school, or it may be something you\u0026rsquo;ve never encountered before. Here you\u0026rsquo;ll find guides to help you get up to speed and examples of how these concepts are applied to making games.\nIn this section:  Interpolation   Transforms   Noise   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/recipes/",
	"title": "Misc",
	"tags": [],
	"description": "",
	"content": "  Misc Other recipes that just don\u0026rsquo;t fit in anywhere else.\nIn this section:  Inheritance   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/physics/",
	"title": "Physics",
	"tags": [],
	"description": "",
	"content": "  Physics Learn how to use Godot\u0026rsquo;s physics nodes.\nIn this section:  Using KinematicBody2D   Using Rigid Bodies   Kinematic Friction   RigidBody2D: Drag and Drop   Kinematic to Rigid Body Interaction   Using 2D Joints   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/ai/",
	"title": "AI/Behavior",
	"tags": [],
	"description": "",
	"content": "  AI/Behavior Automated behavior and (sometimes) smarter entities.\nIn this section:  Chasing the player   Path following   Changing behaviors   Homing missile   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/screen_shake/",
	"title": "Screen Shake",
	"tags": [],
	"description": "",
	"content": " Problem You want to create a \u0026ldquo;screen shake\u0026rdquo; effect.\nSolution The \u0026ldquo;screen shake\u0026rdquo; effect is a popular way to add a dynamic feel to your game. When used well, it adds a lot of appeal. When misused, players hate it. Keep this in mind when adding it to your game and use wisely.\nThe effect is quite simple: when an event occurs - an explosion, a heavy object hitting an obstacle, etc. - we want to rapidly displace the camera in small increments for a brief time.\nThere are many ways to implement this effect. For this recipe, we\u0026rsquo;ll be emulating the technique outlined in the following GDC talk:\n  To summarize, the camera will have a trauma property, measuring how much the camera is shaking. Every time something happens that should shake the camera, we\u0026rsquo;ll add a bit more trauma - a large amount for big events or a little for small ones. Over time, the trauma decreases.\nTrauma We\u0026rsquo;ll start by implementing the camera. Make a new scene with a Camera2D node, name it ShakeCamera2D, and attach a script.\nFirst, define the parameters that control the shake behavior:\nextends Camera2D export var decay = 0.8 # How quickly the shaking stops [0, 1]. export var max_offset = Vector2(100, 75) # Maximum hor/ver shake in pixels. export var max_roll = 0.1 # Maximum rotation in radians (use sparingly). export (NodePath) var target # Assign the node this camera will follow. var trauma = 0.0 # Current shake strength. var trauma_power = 2 # Trauma exponent. Use [2, 3]. trauma_power is the relationship between trauma and the actual movement of the camera (ie amount = trauma * trauma). A square (2) or cube (3) relationship is typically the best, but feel free to experiment.\nWe\u0026rsquo;ve also added a target variable so that you can place an instance of this camera anywhere you like and set the target node it will follow.\nfunc _ready(): randomize() func add_trauma(amount): trauma = min(trauma + amount, 1.0) The add_trauma() function is what we call to start or increase shaking. Pass it a value from 0 to 1.\nfunc _process(delta): if target: global_position = get_node(target).global_position if trauma: trauma = max(trauma - decay * delta, 0) shake() In process() we\u0026rsquo;ll move the camera to track its target. If there is any trauma, we\u0026rsquo;ll use decay to reduce it and then call shake() to move the camera.\nRandom displacement The shake() function applies a random movement to the camera based on the current trauma level (raised to the given power). In 2D, we have two translational and one rotational movement to calculate. Picking a random number between -1 and 1 is an easy way to get a movement in either direction.\nfunc shake(): var amount = pow(trauma, trauma_power) rotation = max_roll * amount * rand_range(-1, 1) offset.x = max_offset.x * amount * rand_range(-1, 1) offset.y = max_offset.y * amount * rand_range(-1, 1) This looks OK, but we can make it look better.\nUsing noise The drawback with using rand_range() for the movement is that it can change greatly from frame to frame, making for a rather erratic feel. To get a more \u0026ldquo;smooth\u0026rdquo; randomness, we can turn to something called noise.\nNoise, or more specifically gradient noise is a method for generating more natural-looking \u0026ldquo;random\u0026rdquo; patterns. To do this, Godot provides the OpenSimplexNoise class.\nProbably the most well-known gradient noise algorithm is called Perlin noise. Because it and its successor, simplex noise, are protected by patents, Godot uses an algorithm called OpenSimplex to generate noise.\n OpenSimplexNoise works by generating a 3D \u0026ldquo;cloud\u0026rdquo; of points. Each point has a value ranging from -1 to 1. Below are two examples of noise generated by OpenSimplexNoise. In the images, each pixel\u0026rsquo;s white value is mapped to the noise value at that point.\nAs you can see, while \u0026ldquo;noisy\u0026rdquo;, if you pick a particular pixel, adjacent pixels may vary unpredictably, but won\u0026rsquo;t suddenly swing wildly from one extreme to another. The behavior can be adjusted to suit your needs, but we won\u0026rsquo;t go into the details of configuring OpenSimplexNoise here. See the related recipes section below for links to more information.\nAdd the following code at the top of the script:\nonready var noise = OpenSimplexNoise.new() var noise_y = 0 func _ready(): randomize() noise.seed = randi() noise.period = 4 noise.octaves = 2 Then, in the shake() function:\nnoise_y += 1 rotation = max_roll * amount * noise.get_noise_2d(noise.seed, noise_y) offset.x = max_offset.x * amount * noise.get_noise_2d(noise.seed*2, noise_y) offset.y = max_offset.y * amount * noise.get_noise_2d(noise.seed*3, noise_y) get_noise_2d() returns the noise value at a given (x, y) coordinate. We don\u0026rsquo;t want to use the same noise value for all three offsets, so we\u0026rsquo;re arbitrarily choosing three different (but distant) x values in the noise, and then using the steadily increasing noise_y value to \u0026ldquo;move\u0026rdquo; along the gradient at each point.\nDownload the project file here: screen_shake.zip\n Related recipes  Noise Platform character  Like video?   -- "
},
{
	"uri": "http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_06/",
	"title": "Sound and Colors",
	"tags": [],
	"description": "",
	"content": " Settings singleton First, we\u0026rsquo;ll add a new script by choosing File -\u0026gt; New Script in the script tab. Name the script settings.gd.\nIn this script we\u0026rsquo;ll place the configuration settings for the game.\nvar enable_sound = true var enable_music = true var circles_per_level = 5 Add the script as an autoload by opening \u0026ldquo;Project Settings\u0026rdquo; and selecting the \u0026ldquo;Autoloads\u0026rdquo; tab. Click the folder to load the script and then click \u0026ldquo;Add\u0026rdquo;.\nAdding sound To play sounds, we\u0026rsquo;ll be adding several AudioStreamPlayer nodes to different scenes.\n First, add one to the Main scene and name it \u0026ldquo;Music\u0026rdquo;. For its Stream property use res://assets/audio/Music_Light-Puzzles.ogg.\n To the Screens scene, add another called \u0026ldquo;Click\u0026rdquo;, which will play when we tap buttons. Use menu_click.wav from the assets folder.\n In the Circle scene, add an audio player named \u0026ldquo;Beep\u0026rdquo; and use the 89.ogg sound file.\n Finally, on the Jumper, we need two sound effects: \u0026ldquo;Jump\u0026rdquo; and \u0026ldquo;Capture\u0026rdquo;. Use 70.ogg and 88.ogg, respectively.\n  Now to play the sounds, we can call their play() methods. Add this to Main.new_game():\nif settings.enable_music: $Music.play() and Main._on_Jumper_died():\nif settings.enable_music: $Music.stop() In Screens.gd add this to _on_button_pressed():\nif settings.enable_sound: $Click.play() On the circle, we want to play the Beep sound when a limited circle completes a full orbit. This is in check_orbits():\ncurrent_orbits -= 1 if settings.enable_sound: $Beep.play() And in Jumper.gd, we add the sounds like so:\nfunc jump(): target.implode() target = null velocity = transform.x * jump_speed if settings.enable_sound: $Jump.play() func _on_Jumper_area_entered(area): target = area velocity = Vector2.ZERO emit_signal(\u0026#34;captured\u0026#34;, area) if settings.enable_sound: $Capture.play() Run the game and test that you hear all the sounds as expected.\nSound settings Now that we have sound working, we can connect the buttons on the \u0026ldquo;Settings\u0026rdquo; screen that can toggle sound and music.\nThe button appearance needs to be changed to match the current on/off state of the property. We\u0026rsquo;ll load the textures first so that we can assign them as needed:\nvar sound_buttons = {true: preload(\u0026#34;res://assets/images/buttons/audioOn.png\u0026#34;), false: preload(\u0026#34;res://assets/images/buttons/audioOff.png\u0026#34;)} var music_buttons = {true: preload(\u0026#34;res://assets/images/buttons/musicOn.png\u0026#34;), false: preload(\u0026#34;res://assets/images/buttons/musicOff.png\u0026#34;)} Right now, we\u0026rsquo;re not handling the buttons when they\u0026rsquo;re pressed. The issue is that we\u0026rsquo;re currently passing the button\u0026rsquo;s name, which won\u0026rsquo;t let us change its texture. Instead, we\u0026rsquo;re going to refactor register_buttons() to pass a reference to the button itself:\nbutton.connect(\u0026#34;pressed\u0026#34;, self, \u0026#34;_on_button_pressed\u0026#34;, [button]) Then we can update _on_button_pressed() like so:\nfunc _on_button_pressed(button): if settings.enable_sound: $Click.play() match button.name: \u0026#34;Home\u0026#34;: change_screen($TitleScreen) \u0026#34;Play\u0026#34;: change_screen(null) yield(get_tree().create_timer(0.5), \u0026#34;timeout\u0026#34;) emit_signal(\u0026#34;start_game\u0026#34;) \u0026#34;Settings\u0026#34;: change_screen($SettingsScreen) \u0026#34;Sound\u0026#34;: settings.enable_sound = !settings.enable_sound button.texture_normal = sound_buttons[settings.enable_sound] \u0026#34;Music\u0026#34;: settings.enable_music = !settings.enable_music button.texture_normal = music_buttons[settings.enable_music] Color themes We\u0026rsquo;re also goign to add a way to have different color schemes. These can change in different ways: perhaps as a settings option, or they change as the player gets to higher levels.\nWe\u0026rsquo;ll store the color scheme data in a dictionary, with the keys being the \u0026ldquo;name\u0026rdquo; of the scheme. Each color scheme will also be a dictionary, with the keys denoting the game component that will use that color.\nAdd this to settings.gd:\nvar color_schemes = { \u0026#34;NEON1\u0026#34;: { \u0026#39;background\u0026#39;: Color8(0, 0, 0), \u0026#39;player_body\u0026#39;: Color8(203, 255, 0), \u0026#39;player_trail\u0026#39;: Color8(204, 0, 255), \u0026#39;circle_fill\u0026#39;: Color8(255, 0, 110), \u0026#39;circle_static\u0026#39;: Color8(0, 255, 102), \u0026#39;circle_limited\u0026#39;: Color8(204, 0, 255) }, \u0026#34;NEON2\u0026#34;: { \u0026#39;background\u0026#39;: Color8(0, 0, 0), \u0026#39;player_body\u0026#39;: Color8(246, 255, 0), \u0026#39;player_trail\u0026#39;: Color8(255, 255, 255), \u0026#39;circle_fill\u0026#39;: Color8(255, 0, 110), \u0026#39;circle_static\u0026#39;: Color8(151, 255, 48), \u0026#39;circle_limited\u0026#39;: Color8(127, 0, 255) }, \u0026#34;NEON3\u0026#34;: { \u0026#39;background\u0026#39;: Color8(0, 0, 0), \u0026#39;player_body\u0026#39;: Color8(255, 0, 187), \u0026#39;player_trail\u0026#39;: Color8(255, 148, 0), \u0026#39;circle_fill\u0026#39;: Color8(255, 148, 0), \u0026#39;circle_static\u0026#39;: Color8(170, 255, 0), \u0026#39;circle_limited\u0026#39;: Color8(204, 0, 255) } } var theme = color_schemes[\u0026#34;NEON1\u0026#34;] Now on each object, we need to set the colors based on the settings property.\nFor the circle, the color is set using the shader material resource. Because resources are shared, that means that changing one circle\u0026rsquo;s color would change them all. Let\u0026rsquo;s make each circle\u0026rsquo;s material unique to avoid this:\n$Sprite.material = $Sprite.material.duplicate() $SpriteEffect.material = $Sprite.material The color of the circle is determined by what mode it\u0026rsquo;s using, so set_mode() is where we\u0026rsquo;ll choose the color:\nfunc set_mode(_mode): mode = _mode var color match mode: MODES.STATIC: $Label.hide() color = settings.theme[\u0026#34;circle_static\u0026#34;] MODES.LIMITED: current_orbits = num_orbits $Label.text = str(current_orbits) $Label.show() color = settings.theme[\u0026#34;circle_limited\u0026#34;] $Sprite.material.set_shader_param(\u0026#34;color\u0026#34;, color) Then in the _draw() function where we\u0026rsquo;re filling in the limited circle, replace the red color with settings.theme[\u0026quot;circle_fill\u0026quot;].\nFor the player, set the color in its _ready():\nfunc _ready(): $Sprite.material.set_shader_param(\u0026#34;color\u0026#34;, settings.theme[\u0026#34;player_body\u0026#34;]) $Trail/Points.default_color = settings.theme[\u0026#34;player_trail\u0026#34;] In the next part, we\u0026rsquo;ll add a movement to the circles.\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/g101/3d/101_3d_06/",
	"title": "Using CSG",
	"tags": [],
	"description": "",
	"content": " Earlier, we saw how to design a 3D environment using imported models. But what if you want to make something like a room, with walls, doors, ramps, and other features, but you don\u0026rsquo;t have any models handy? CSG to the rescue!\nWhat is CSG? CSG stands for Constructive Solid Geometry. It allows you to combine primitive shapes to build complex geometry. Shapes can be combined with boolean operations such as Union, Intersection, and Subtraction.\nCSG is a great tool for prototyping environments and game objects. Later in this tutorial, we\u0026rsquo;ll use it to make a small FPS-style level with some ramps, walls and platforms.\nBefore we do that, let\u0026rsquo;s get introduced to how the CSG nodes work.\nCSG Basics Create a new scene with a Spatial root, then add a child node and type \u0026ldquo;CSG\u0026rdquo; in the search box.\nThese are the available CSG shapes. Choose a CSGBox to start. You\u0026rsquo;ll see a plain cube mesh with the following properties:\nThe Operation property is the one that determines how CSG shapes will be combined. The options are:\n Union - The shapes will be merged, removing any \u0026ldquo;inside\u0026rdquo; geometry. Intersection - Only the intersecting (overlapping) geometry will be kept. Subtraction - The second shape is \u0026ldquo;cut out\u0026rdquo; of the first.  CSG operations are performed on a shape by adding children. Add a child CSGCylinder to the CSGBox. Drag the top size handle (orange dot) to make it a bit taller. You can also increase the Sides property to make it look more circular (here it\u0026rsquo;s set to 20):\nBy default, the shape\u0026rsquo;s operation is set to \u0026ldquo;Union\u0026rdquo;. The cylinder shape is being \u0026ldquo;added\u0026rdquo; to the cube. Try changing it to \u0026ldquo;Intersection\u0026rdquo;:\nAnd \u0026ldquo;Subtraction\u0026rdquo;:\nHopefully you\u0026rsquo;re already seeing the possibilities of creating complex shapes through these 3 operations.\nCSGCombiner This node is an \u0026ldquo;empty\u0026rdquo; shape. It\u0026rsquo;s used to organize your shapes. Children of a CSGCombiner will be combined following the same rules as above.\nBuilding a Room Now we\u0026rsquo;re going to make something useful: a large room with some obstacles and features that our character can interact with, and that we can use in the upcoming tutorials. Make a new scene with a Spatial root that we can start working with.\nStart with a CSGBox, and set its Width and Depth to 20 and its Height to 5. We need this to be a box that we go inside, so click the Invert Faces property as well. This reverses the shape so that the solid walls are on the inside rather than the outside. Also check the Use Collision property, so that the physics engine will treat this shape as a static body object.\nAdd an instance of the player character and test that you can walk around in your new room.\nYou may remember that in the last part we added code to capture/release the mouse. You\u0026rsquo;ll need to copy that code over to this scene as well.\n Adding features Now let\u0026rsquo;s add some features - some internal walls, a ledge running around the edge with a ramp, and so on. Feel free to get creative and add your own ideas. Here are a few to get started:\nIf you use a CSGCombiner for each of these objects it will be easier to organize and duplicate them. Make sure to enable Use Collision on it.\n  Wall with door  Add a CSGBox and set its Width to 0.5 and its Height to 5 (the same height as the original room). Make the depth about half the size of the room. You can enable snapping here to make it easier to align.\nAdd another CSGBox as a child and set it to \u0026ldquo;Subtract\u0026rdquo;. Size it to resemble a door. You can also use a cylinder shape to get an arched portal.\n Ramp  For the ramp, we\u0026rsquo;ll use a CSGPolygon. This CSG shape lets you extrude a given polygon to a desired depth. The default shape is a square, but you can add or remove points. For a ramp, we want 3 points.\nAfter adding the CSGPolygon, you can click the Polygon property to adjust its number of points. After that, you can drag the three points to whatever location you like. To ensure everything lines up, you can type the coordinates into the Inspector:\nIn this picture, we\u0026rsquo;ve created a ramp and added a couple of CSGBox shapes to make the ledge.\nPutting it together Make sure to add a Material to your shapes, choosing an Albedo color that seems pleasant to you. In the following examples, we\u0026rsquo;ve picked a tan color.\nHere\u0026rsquo;s an example of a possible room setup:\nHit play and you should be able to walk around the rooms:\nThe area is featureless right now, but to make things more visually interesting, you can add individual lights in each room (more about lighting in a later tutorial). Here\u0026rsquo;s an example of adding some OmniLight and SpotLight nodes to the scene:\nWrapping Up CSG is a powerful tool for building objects directly in Godot without having to move to another modeling application such as Blender. It can be helpful if you need to mock up a test level for your game, or for the final environment. Keep in mind that as the CSG tree becomes more complex, it can incur a performance penalty. Try to use CSGCombiner to separate your scene into separate CSG trees to minimize this.\nIn the next part, we\u0026rsquo;ll look at a popular style of 3D game: first person.\nYou can also find a video version of this lesson here:   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/shaders/",
	"title": "Shaders",
	"tags": [],
	"description": "",
	"content": "  Shaders Deep voodoo. Cool effects.\nIn this section:  Shaders: intro   Interacting with Shaders   Greyscale (monochrome) shader   Blur shader   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/g101/3d/101_3d_07/",
	"title": "First-person Character",
	"tags": [],
	"description": "",
	"content": " In this installment, we\u0026rsquo;ll look at how to make a first-person character. We\u0026rsquo;ll use the CSG-based level we designed in the previous part as a place to walk around and test our movement.\nCharacter Scene In an FPS or similar game, we want to give the player the illusion that they\u0026rsquo;re looking out of the character\u0026rsquo;s eyes. One nice aspect of this is that we don\u0026rsquo;t really need a model, at least to get started.\nStart with a KinematicBody. To this we\u0026rsquo;ll add two CollisionShape nodes (\u0026ldquo;Body\u0026rdquo; and \u0026ldquo;Feet\u0026rdquo;). We also want to have a Camera, but we need to be careful about how we handle rotation. The character should rotate in Y, but only the camera should rotate in X (for looking up and down). To make this work, add a Spatial node, which we\u0026rsquo;ll call \u0026ldquo;Pivot\u0026rdquo;, and add the Camera to that.\nThe \u0026ldquo;Body\u0026rdquo; collision shape is going to represent the player\u0026rsquo;s body. We can use a CapsuleShape (rotated 90 degrees around X). Set its Radius to 0.5 and Height to 1.\nOne issue with using a CapsuleShape is that the bottom is rounded. This is good for moving over small bumps in a natural way, but it also means that when standing on the edge of a surface, the player will \u0026ldquo;roll\u0026rdquo; off in a strange way. We can prevent this by using a BoxShape for the \u0026ldquo;Feet\u0026rdquo; collision. Make its extents (.4, .1, .4) and place it so that its bottom is just above the bottom of the capsule. We\u0026rsquo;ll still have the round bottom to move over things, but the box will keep us from sliding off ledges.\nMove the Pivot up a bit, so that it\u0026rsquo;s not pointing the camera out of the \u0026ldquo;middle\u0026rdquo; of the body.\nMoving around Much of the code for movement is the same as we used for the third-person character earlier in this series. We\u0026rsquo;ll start with declaring our variables:\nextends KinematicBody onready var camera = $Pivot/Camera var gravity = -30 var max_speed = 8 var mouse_sensitivity = 0.002 # radians/pixel var velocity = Vector3() The value of mouse_sensitivity maps the movement of the mouse, which is in pixels, to rotation, in degrees. So for each pixel the mouse moves, we\u0026rsquo;ll rotate by 0.002 radians (or about 0.1 degrees).\n func get_input(): var input_dir = Vector3() # desired move in camera direction if Input.is_action_pressed(\u0026#34;move_forward\u0026#34;): input_dir += -camera.global_transform.basis.z if Input.is_action_pressed(\u0026#34;move_back\u0026#34;): input_dir += camera.global_transform.basis.z if Input.is_action_pressed(\u0026#34;strafe_left\u0026#34;): input_dir += -camera.global_transform.basis.x if Input.is_action_pressed(\u0026#34;strafe_right\u0026#34;): input_dir += camera.global_transform.basis.x input_dir = input_dir.normalized() return input_dir When detecting input, we want to move in the direction the camera is facing, which is not necessarily the current movement direction. Although we\u0026rsquo;re not going to do it yet, this will allow us to implement friction and acceleration for a more natural movement feel.\nWe add up the inputs and return the resulting direction vector.\nfunc _unhandled_input(event): if event is InputEventMouseMotion and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED: rotate_y(-event.relative.x * mouse_sensitivity) $Pivot.rotate_x(-event.relative.y * mouse_sensitivity) $Pivot.rotation.x = clamp($Pivot.rotation.x, -1.2, 1.2) We also need to capture mouse movement for camera rotation. As discussed above, horizontal mouse movement rotates the entire body in Y, while vertical motion rotates the helper node in X.\nWe also need to limit that vertical rotation to prevent the camera from flipping upside-down.\nfunc _physics_process(delta): velocity.y += gravity * delta var desired_velocity = get_input() * max_speed velocity.x = desired_velocity.x velocity.z = desired_velocity.z velocity = move_and_slide(velocity, Vector3.UP, true) In _physics_process() we get the desired_velocity, the direction vector returned by get_input(), and multiply it by max_speed to set its length. We don\u0026rsquo;t want to alter our velocity.y because that\u0026rsquo;s set by gravity, so we only set the x and z components based on the input.\nWe\u0026rsquo;re also setting true for the stop_on_slope parameter of move_and_slide(). This keeps us from sliding down the ramp if we stand on it.\nTest your movement and ensure everything is working as expected.\nAdding a weapon First person characters typically have some sort of item, or at least empty hands, visible in front of them. We\u0026rsquo;re going to use the shotgun model from the following art pack:\nKenney Weapon Pack\nAddd a MeshInstance to the Pivot node and use the shotgun.obj model from the art pack. You\u0026rsquo;ll notice that the model is too small for our player\u0026rsquo;s scale, so set Scale to (8, 8, 8).\nWe need to position the model so that it\u0026rsquo;s projecting out \u0026ldquo;through\u0026rdquo; the camera. Aligning it can be difficult, so click the \u0026ldquo;View\u0026rdquo; menu and choose \u0026ldquo;2 Viewports\u0026rdquo;. In the bottom one, select the Camera and click \u0026ldquo;Preview\u0026rdquo;, and in the top you can move the gun until it looks right.\nWrapping up We now have a basic first-person character controller. This could make a good foundation for a wide variety of game types by adding features and behaviors, as we\u0026rsquo;ll see in later lessons.\nYou can also find a video version of this lesson here:   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/input/multi_unit_select/",
	"title": "Mouse: Drag-select multiple units",
	"tags": [],
	"description": "",
	"content": " Problem You want to click-and-drag to select multiple units, RTS style.\nSolution Realtime strategy (RTS) games often require giving orders to many units at once. A typical style of selecting multiple units is to click-and-drag a box around them. Once the units are selected, clicking on the map commands them to move.\nHere\u0026rsquo;s an example of what we\u0026rsquo;re going for:\nUnit setup To test this out, we\u0026rsquo;ll need some basic RTS-style units. They are set up to move towards a target and to avoid running into each other. We won\u0026rsquo;t go into too much detail on them in this tutorial. The unit script is commented if you\u0026rsquo;d like to use it as a base for creating your own RTS units. See below for a link to download the project.\nWorld setup Processing the unit selection will happen in the world. We\u0026rsquo;ll start with a Node2D called \u0026ldquo;World\u0026rdquo; and add a few unit instances in it. Attach a script to the World node and add the following variables:\nextends Node2D var dragging = false # Are we currently dragging? var selected = [] # Array of selected units. var drag_start = Vector2.ZERO # Location where drag began. var select_rect = RectangleShape2D.new() # Collision shape for drag box. Note that once we\u0026rsquo;ve drawn the box, we\u0026rsquo;ll need a way to find what units are inside it. The RectangleShape2D will allow us to query the physics engine and see what we collided with.\nDrawing the box We\u0026rsquo;ll be using the left mouse button for this. Clicking starts a drag and then letting go ends it. During dragging, we\u0026rsquo;ll draw the rectangle for visibility.\nfunc _unhandled_input(event): if event is InputEventMouseButton and event.button_index == BUTTON_LEFT: if event.pressed: # We only want to start a drag if there\u0026#39;s no selection. if selected.size() == 0: dragging = true drag_start = event.position elif dragging: # Button released while dragging. dragging = false if event is InputEventMouseMotion and dragging: update() func _draw(): if dragging: draw_rect(Rect2(drag_start, get_global_mouse_position() - drag_start), Color(.5, .5, .5), false) Selecting the units Now that we\u0026rsquo;ve got a selection box, we need to find the units that are inside it. When we release the button and the drag ends, we must query the physics space to find the units. Note that the units are KinematicBody2D, but Area2D or other bodies would work as well.\nWe\u0026rsquo;ll use Physics2DDirectSpaceState.intersect_shape() to find the units. This requires a shape (our rectangle) and a transform (our location). See Godot docs for details.\nelif dragging: dragging = false update() var drag_end = event.position select_rect.extents = (drag_end - drag_start) / 2 We start by recording the location when we released the button, and use that to set the RectangleShape2D\u0026rsquo;s extents (remember: extents are measured from the rectangle\u0026rsquo;s center, so they\u0026rsquo;re half the full width/height).\nvar space = get_world_2d().direct_space_state var query = Physics2DShapeQueryParameters.new() query.set_shape(select_rect) query.transform = Transform2D(0, (drag_end + drag_start) / 2) selected = space.intersect_shape(query) Now we must get a reference to the physics state and set up our shape query using Physics2DShapeQueryParameters, assigning it our shape, and using the center of the dragged area as the origin for the query\u0026rsquo;s transform. Our result after calling intersect_shape() is an array of dictionaries, which looks like this:\n[{collider:[KinematicBody2D:1149], collider_id:1149, metadata:Null, rid:[RID], shape:0}, {collider:[KinematicBody2D:1144], collider_id:1144, metadata:Null, rid:[RID], shape:0}, {collider:[KinematicBody2D:1154], collider_id:1154, metadata:Null, rid:[RID], shape:0}, {collider:[KinematicBody2D:1159], collider_id:1159, metadata:Null, rid:[RID], shape:0}]  Each of those collider items is a reference to a unit, so we can use this to notify them that they\u0026rsquo;ve been selected, activating the outline shader:\nfor item in selected: item.collider.selected = true Commanding the units Finally, we can command the selected units to move by clicking somewhere on the screen:\nfunc _unhandled_input(event): if event is InputEventMouseButton and event.button_index == BUTTON_LEFT: if event.pressed: if selected.size() == 0: dragging = true drag_start = event.position else: for item in selected: item.collider.target = event.position item.collider.selected = false selected = [] The else clause here triggers if we click the mouse when selected is greater than 0. Each item\u0026rsquo;s target is set, and we make sure to deselect the units so we can start again.\nWrapping up This technique can be expanded to a wide range of RTS or other game styles. Download the full project below and use it as a base for your own game.\nDownload the project file here: rts_movement.zip\n Related recipes  Mouse Input Inputs: Introduction  Like video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_07/",
	"title": "Moving circles",
	"tags": [],
	"description": "",
	"content": " Fixing a bug Our first task is to fix a bug with our menu system. Pressing the \u0026ldquo;Start\u0026rdquo; button launches a new game, but as the screen is moving off, it can be pressed again. Try \u0026ldquo;spamming\u0026rdquo; the start button - disaster ensues!\nWe can fix this by disabling the buttons while the screen transition is happening. Since we put all the buttons in a \u0026ldquo;buttons\u0026rdquo; group, we can easily do this with call_group().\nHere\u0026rsquo;s the updated BaseScreen.gd:\nextends CanvasLayer onready var tween = $Tween func appear(): get_tree().call_group(\u0026#34;buttons\u0026#34;, \u0026#34;set_disabled\u0026#34;, false) tween.interpolate_property(self, \u0026#34;offset:x\u0026#34;, 500, 0, 0.5, Tween.TRANS_BACK, Tween.EASE_IN_OUT) tween.start() func disappear(): get_tree().call_group(\u0026#34;buttons\u0026#34;, \u0026#34;set_disabled\u0026#34;, true) tween.interpolate_property(self, \u0026#34;offset:x\u0026#34;, 0, 500, 0.5, Tween.TRANS_BACK, Tween.EASE_IN_OUT) tween.start() Score and level As our score increases, we\u0026rsquo;ll want the game\u0026rsquo;s difficulty to increase as well. This means that when we get points, we\u0026rsquo;ll need to check if we\u0026rsquo;ve passed a certain threshold (circles_per_level). We may also have other things that give us points besides jumping on a circle. To make this easier to handle, we\u0026rsquo;ll give our score variable a setget method in the main script:\nvar score = 0 setget set_score var level = 0 And update the new_game() to use that method:\nfunc new_game(): self.score = 0 level = 1 Do the same with the score change in _on_Jumper_captured(), and we\u0026rsquo;ll move the HUD update into our new set_score() method:\nfunc _on_Jumper_captured(object): $Camera2D.position = object.position object.capture(player) call_deferred(\u0026#34;spawn_circle\u0026#34;) self.score += 1 func set_score(value): score = value $HUD.update_score(score) if score \u0026gt; 0 and score % settings.circles_per_level == 0: level += 1 $HUD.show_message(\u0026#34;Level %s\u0026#34; % str(level)) Try the game and you should see a \u0026ldquo;Level 2\u0026rdquo; message on the screen when you reach five points.\nMoving circles Part of the level progression is going to be increased difficulty. One way we\u0026rsquo;ll do that is by making some circles move. We already have multiple circle types (static and limited), but either of those should be capable of moving, so this won\u0026rsquo;t be a new circle type. Instead, it will be a property that any circle can have.\nOpen up the Circle scene and add a Tween node called \u0026ldquo;MoveTween\u0026rdquo;. Add this to the top of the circle script:\nonready var move_tween = $MoveTween var move_range = 100 # Distance the circle moves. var move_speed = 1.0 # The circle\u0026#39;s movement speed. If move_range is 0, we\u0026rsquo;ll have a non-moving circle. We\u0026rsquo;ll make the default 100 here so that we can test it out.\nTo handle the movement, we\u0026rsquo;ll start the MoveTween. When it ends, we\u0026rsquo;ll start it again in the opposite direction, using the tween_completed signal.\nThis is the code to start the movement. Connect the tween_completed signal to this function:\nfunc set_tween(object=null, key=null): if move_range == 0: return move_range *= -1 move_tween.interpolate_property(self, \u0026#34;position:x\u0026#34;, position.x, position.x + move_range, move_speed, Tween.TRANS_QUAD, Tween.EASE_IN_OUT) move_tween.start() Finally, we\u0026rsquo;ll add set_tween() to the end of the init() function and we can try it out.\n Follow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/physics/joints_2d/",
	"title": "Using 2D Joints",
	"tags": [],
	"description": "",
	"content": " Problem You\u0026rsquo;d like to understand Godot\u0026rsquo;s Joint2D nodes.\nSolution Joint are used to constrain the movement of attached physics objects. For any joint node, you need to attach two bodies, which must extend from PhysicsObject2D.\nProperties These properties are common to all joint nodes:\n Node A and Node B: The assigned physics bodies. Bias: The rate at which the joint pulls the two bodies back together if they move apart. Defaults to 0. Disable Collisions: Allows the connected bodies to ignore collisions between them. Defaults to true.  There are three types of Joint2D. In all of the following examples, there is one RigidBody2D connected via a joint to a StaticBody2D. \u0026ldquo;Visible Collision Shapes\u0026rdquo; is enabled in the screen images below so you can see a representation of the joint.\nPinJoint2D The \u0026ldquo;pin\u0026rdquo; joint attaches the two bodies at a single point, allowing them to freely rotate.\nThe pin joint\u0026rsquo;s Softness property gives some \u0026ldquo;springiness\u0026rdquo; to the connection. The value can range from 0 (the default) which allows no movement, to 16.\nDampedSpringJoint2D This joint connects the two bodies with a spring-like force.\nThe spring\u0026rsquo;s behavior can be adjusted with these properties:\n Length: The joint\u0026rsquo;s maximum length. Rest Length:The joint\u0026rsquo;s length when no forces or movement are applied. Stiffness: The spring\u0026rsquo;s \u0026ldquo;stretchiness\u0026rdquo;, i.e. how much it resists forces pulling against it. Damping: How quickly the spring stops \u0026ldquo;bouncing\u0026rdquo;.  GrooveJoint2D This joint constrains the attached bodies to move linearly.\nBy default, the groove runs vertically, but you can change this by rotating the groove node.\nThese properties control the groove\u0026rsquo;s behavior:\n Length: The groove\u0026rsquo;s length. The attached bodies can\u0026rsquo;t move past this maximum distance. Initial Offset: Starting \u0026ldquo;position\u0026rdquo; along the groove.  You can download an example project to play with these joints here: physics_joints.zip\nRelated Recipes "
},
{
	"uri": "http://kidscancode.org/godot_recipes/export/",
	"title": "Exporting",
	"tags": [],
	"description": "",
	"content": "  Exporting Building and exporting your project for PC, web, or mobile.\nIn this section:  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/ui/unit_healthbar/",
	"title": "Object Healthbars",
	"tags": [],
	"description": "",
	"content": " Problem You want units in your game to have healthbars that follow them as they move.\nSolution Displaying the bar can be done with a TextureProgress node. This is like the ProgressBar node, but allows the use of textures for the bar itself. The length of the bar will indicate the health value, but we can also change the texture color. We\u0026rsquo;ll use three colored bars for this:\nSo that this bar can be added to any unit in the game, we\u0026rsquo;ll make it a separate scene. Start with a Node2D and a TextureProgress child. Add a script to the root node.\nDrag the green bar into the TextureProgress Textures/Progress property and set its Value to 100. Drag the bar until it\u0026rsquo;s centered and above the origin.\nextends Node2D var bar_red = preload(\u0026#34;res://assets/barHorizontal_red.png\u0026#34;) var bar_green = preload(\u0026#34;res://assets/barHorizontal_green.png\u0026#34;) var bar_yellow = preload(\u0026#34;res://assets/barHorizontal_yellow.png\u0026#34;) onready var healthbar = $HealthBar The script starts by loading the three colored bars, which will change as the health decreases. We also store a reference to the progress bar.\nfunc _ready(): hide() if get_parent() and get_parent().get(\u0026#34;max_health\u0026#34;): healthbar.max_value = get_parent().max_health The HealthDisplay should be attached to a unit. If the unit has a max_health property, we use that to set the range of the bar (it\u0026rsquo;s 100 by default). We also want the bar to start out hidden, and appear if the unit loses health.\nfunc _process(delta): global_rotation = 0 This prevents the bar from rotating. It will always remain on top of the unit it\u0026rsquo;s attached to.\nfunc update_healthbar(value): healthbar.texture_progress = bar_green if value \u0026lt; healthbar.max_value * 0.7: healthbar.texture_progress = bar_yellow if value \u0026lt; healthbar.max_value * 0.35: healthbar.texture_progress = bar_red if value \u0026lt; healthbar.max_value: show() healthbar.value = value Finally, we have a function we can call when the unit\u0026rsquo;s health changes. It updates the value of the bar and sets the texture based on the remaining proportion.\nWhen you attach this to a unit, the bar may appear too big. Set the Scale property of the instanced HealthDisplay to adjust based on the size of your unit.\nHere\u0026rsquo;s an example of this system in use. You can download the example project for this below.\n Download the project file here: tower_defense_demo.zip\n "
},
{
	"uri": "http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_11/",
	"title": "Mobile ads",
	"tags": [],
	"description": "",
	"content": " About ads When building a free-to-play mobile game, you have two choices when it comes to monetization: in-app purchases and advertisement. In this part, we\u0026rsquo;ll look at how to integrate a mobile ad platform (Admob) into your game.\nAds can be unpopular and whether to use them is a decision for the individual game developer to make. We\u0026rsquo;re not making a decision on the pros and cons in this tutorial - we\u0026rsquo;re here to show you how to put ads in your game if you want them.\nSet up Admob Head over to Admob and create an account.\nIn the AdMob manager, create a new app - ours is titled \u0026ldquo;Circle Jump\u0026rdquo; - and specify the \u0026ldquo;Android\u0026rdquo; platform (we\u0026rsquo;ll discuss iOS later).\nIn the \u0026ldquo;Circle Jump\u0026rdquo; app, you\u0026rsquo;ll need to create three \u0026ldquo;Ad Units\u0026rdquo;. These are the types of ads that you can show in your game. For this tutorial, we\u0026rsquo;ll need a \u0026ldquo;Banner\u0026rdquo; and an \u0026ldquo;Interstitial\u0026rdquo;. Each ad unit will have an \u0026ldquo;Ad Unit ID\u0026rdquo;, a long string of characters - we\u0026rsquo;ll need that later in the game.\nUsing Godot modules Godot doesn\u0026rsquo;t include ad services by default, so it\u0026rsquo;s necessary to use an engine module, or plugin, to add that functionality. You can find the module we\u0026rsquo;ll be using here: godot-admob. On that page, you\u0026rsquo;ll see a list of the methods provided by the plugin.\nTo use a custom engine module, the engine has to be recompiled. In the case of mobile platforms, that means recompiling the export templates because the default ones we downloaded from Godot weren\u0026rsquo;t compiled with this module.\nCompiling export templates is not difficult, but it does require setting up a build environment on your computer - downloading the required programs and libraries needed to build Godot. If you\u0026rsquo;re new to this concept and interested in learning about it, see the Compiling section of the official docs.\nFortunately, we won\u0026rsquo;t need to compile custom export templates, because it\u0026rsquo;s already been done for us. Head over to the godot-custom-mobile-templates Github repo. Click on \u0026ldquo;Releases\u0026rdquo; and download the version of the export templates that matches your version of Godot.\nThe export template version must match the Godot editor version. If you\u0026rsquo;re using a custom-built editor, you will also have to build the templates from the same code branch.\n Unzip the templates somewhere on your computer (don\u0026rsquo;t put them in the Circle Jump project folder).\nConfiguring export Back in the Godot editor, we need to make some changes to the export configuration. First, open Project -\u0026gt; Project Settings and find the \u0026ldquo;Android\u0026rdquo; section. In the Modules property is where you list the module(s) you want to use in your code. The module name is listed on the godot-admob page: \u0026ldquo;org/godotengine/godot/GodotAdMob\u0026rdquo;. If you have more than one module, separate them with commas.\nIn the _Project -\u0026gt; Export_menu, we need to tell Godot to use the custom templates we downloaded. These are set in the \u0026ldquo;Custom Package\u0026rdquo; section. Click the folder icon and navigate to where you unzipped the templates. Make sure to add both the \u0026ldquo;Debug\u0026rdquo; and \u0026ldquo;Release\u0026rdquo; templates.\nCode Now when we run the game (on Android), it will load that module. It\u0026rsquo;s accessed via an engine singleton. Open settings.gd and add the following:\nvar admob = null var real_ads = false var banner_top = false # Fill these from your AdMob account: var ad_banner_id = \u0026#34;\u0026#34; var ad_interstitial_id = \u0026#34;\u0026#34; var enable_ads = true These are our settings variables for the module. real_ads set to false puts us in \u0026ldquo;Test Ad\u0026rdquo; mode. You shouldn\u0026rsquo;t change this to true until you\u0026rsquo;re ready to release your game. banner_top toggles whether the banner ad should be shown at the top or bottom of the screen.\nad_banner_id and ad_interstitial_id should be filled with your ad unit values from your AdMob account.\nWe need to initialize the module:\nfunc _ready(): if Engine.has_singleton(\u0026#34;AdMob\u0026#34;): admob = Engine.get_singleton(\u0026#34;AdMob\u0026#34;) admob.init(real_ads, get_instance_id()) admob.loadBanner(ad_banner_id, banner_top) admob.loadInterstitial(ad_interstitial_id) We first check that the module singleton exists. If it\u0026rsquo;s found, we can initialize the module and load the ad units.\nfunc show_ad_banner(): if admob and enable_ads: admob.showBanner() func hide_ad_banner(): if admob: admob.hideBanner() Next, we have functions to let us show/hide the banner. We only want it showing in the menu screens, not during actual gameplay.\nfunc show_ad_interstitial(): if admob and enable_ads: admob.showInterstitial() We\u0026rsquo;ll use this function to show the interstitial ad at the end of a game.\nfunc _on_interstitial_close(): if admob and enable_ads: show_ad_banner() The module looks for this callback to run any code when the interstitial ad closes. Since we\u0026rsquo;ll be at the end of a game and going back to the menu, we\u0026rsquo;ll show the banner again.\nNow we need to call these functions from the game. Open Main.gd and add the following:\n In new_game(), add settings.hide_ad_banner(). At the end of _on_Jumper_died() add settings.show_ad_interstitial().  Run the game on your device, and you should see the test ad appear:\nDisabling ads Many games allow ads to be disabled, whether via in-app purchases, reaching a certain level, etc. In our case, we\u0026rsquo;ll add it as a button on the \u0026ldquo;Settings\u0026rdquo; screen.\nFirst, we\u0026rsquo;ll change the enable_ads to give it a setter function:\nvar enable_ads = true setget set_enable_ads And add the setter function:\nfunc set_enable_ads(value): enable_ads = value if enable_ads: show_ad_banner() if !enable_ads: hide_ad_banner() This will cause the banner add to appear/disappear instantly when pressing the button.\nTo add the button, we\u0026rsquo;ll need a third row of buttons. Open the BaseScreen scene and duplicate the first HBoxContainer.\nIn the SettingsScreen scene add a Button called \u0026ldquo;Ads\u0026rdquo; to the middle row. Set its text to \u0026ldquo;Disable Ads\u0026rdquo;, its Custom Font (a size of 48 works well), and set its Custom Styles all to \u0026ldquo;New StyleBoxEmpty\u0026rdquo;. Don\u0026rsquo;t forget to add the button to the \u0026ldquo;buttons\u0026rdquo; group.\nIn Screens.gd, add the following to the match statement that processes the buttons:\nmatch button.name: \u0026#34;Ads\u0026#34;: settings.enable_ads = !settings.enable_ads if settings.enable_ads: button.text = \u0026#34;Disable Ads\u0026#34; else: button.text = \u0026#34;Enable Ads\u0026#34; Run the game on your device and verify that you can enable/disable ads.\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/ui/minimap/",
	"title": "Minimap/radar",
	"tags": [],
	"description": "",
	"content": " Problem You want a minimap or radar-style UI item showing the locations of objects outside of the player\u0026rsquo;s view.\nSolution Here\u0026rsquo;s an example of what we are going for: \nProject setup To illustrate this feature, we\u0026rsquo;ll start with a simplified top-down game using the Autotile recipe and a player based on the Top-down character recipe. See the linked recipes for details on how these parts work.\nThe art in this project comes from kenney.nl, which you can download here: Topdown Shooter and Interface Pack.\n Our main scene setup looks like this:\nThe CanvasLayer node is there to hold our UI, including the minimap/radar we\u0026rsquo;re making in this recipe.\nUI Layout The first step will be to create the layout for the minimap. In order to work with whatever other UI elements exist in the game, it must resize smoothly, and integrate well with a container-based layout.\nAdd a MarginContainer first. Set its Custom Constants all to 5. This control will hold the rest of the nodes and ensure it doesn\u0026rsquo;t bleed over into any other elements. Name it \u0026ldquo;MiniMap\u0026rdquo; and save the scene.\nNext, add a NinePatchRect node. This node is similar to a TextureRect but handles resizing differently by not stretching the corners/edges. Drop the panel_woodDetail_blank.png image from the asset folder into the Texture property. This is a 128x128 image and if we scale the root MarginContainer, the image becomes stretched and ugly:\nUsing the NinePatchRects\u0026rsquo;s properties, we can ensure that the frame remains the same size when stretched. You can define these properties graphically in the \u0026ldquo;TextureRegion\u0026rdquo; panel, but it\u0026rsquo;s sometimes easier to enter the values directly. Set all four properties in the Patch Margin section to 64 and change the node\u0026rsquo;s name to \u0026ldquo;Frame\u0026rdquo;.\nNow observe what happens when we change the size:\nNext, we\u0026rsquo;d like to fill in the inner part of the frame with the grid pattern pattern_blueprintPaper.png:\nHowever, we need it to tile automatically no matter what size we make the frame. Also, since this grid area is where our minimap markers will appear, we don\u0026rsquo;t want the grid extending past the edges of the frame.\nAs a child of the MiniMap (and a sibling of the Frame), add another MarginContainer. Set all four margin properties in Custom Constants to 20. As a child of this node, add a TextureRect and assign its Texture to the above image. Set its Stretch Mode to \u0026ldquo;Tile\u0026rdquo;. Name this node \u0026ldquo;Grid\u0026rdquo;.\nTry changing the size of your root node to see the effect:\nFor now, let\u0026rsquo;s leave the minimap\u0026rsquo;s size at (200, 200) - you can check the root node\u0026rsquo;s Rect/Size property to confirm.\nAt this point, your scene tree should look like the following:\nMap Markers As a child of Grid, add a Sprite node named \u0026ldquo;PlayerMarker\u0026rdquo; and give it the minimapIcon_arrowA.png texture. Note the sprite\u0026rsquo;s Transform/Position property: (0, 0), which places it exactly in the top-left corner of the Grid:\nIf our Grid size is currently (150, 150) (you can check this in its Rect/Size property), then its center will be (75, 75). Put the PlayerMarker\u0026rsquo;s Position there:\nDon\u0026rsquo;t worry, we\u0026rsquo;ll automate this later.\nAdd two more Sprite nodes: \u0026ldquo;MobMarker\u0026rdquo; and \u0026ldquo;AlertMarker\u0026rdquo;, using the minimapIcon_jewelRed.png and minimapIcon_exclamationYellow.png textures.\nThese will represent two different types of objects in the game world. Click the \u0026ldquo;Toggle Visibility\u0026rdquo; button next to each so that they won\u0026rsquo;t appear by default.\nScripting the map markers At this point, we have some decisions to make. How we approach populating the minimap with the objects in the world has a lot to do with how the game is set up. Since this is a very minimal demonstration project, we\u0026rsquo;re going keep the process simple. In a larger game, you may need to use a more robust approach.\nFor this demo, we have two game objects: a Mob, which wanders around the map randomly, and a Crate, which the player can pick up. Many of these are scattered around the main scene. Each will need to be represented by one of the map markers we made.\nAdd each item that you want to appear on the minimap to a group named \u0026ldquo;minimap_objects\u0026rdquo;. In each object\u0026rsquo;s script, assign it a minimap_icon property:\n# In the mob\u0026#39;s script: var minimap_icon = \u0026#34;mob\u0026#34; # In the crate\u0026#39;s script: var minimap_icon = \u0026#34;alert\u0026#34; Now we can begin adding a script to the MiniMap. First, a player reference that can be assigned in the Inspector when the minimap is added to the main scene and a zoom property to calibrate the scale - how far the minimap can \u0026ldquo;see\u0026rdquo;. We also have some onready variables to make it more convenient to access the nodes we need.\nextends MarginContainer export (NodePath) var player export var zoom = 1.5 onready var grid = $MarginContainer/Grid onready var player_marker = $MarginContainer/Grid/PlayerMarker onready var mob_marker = $MarginContainer/Grid/MobMarker onready var alert_marker = $MarginContainer/Grid/AlertMarker Next, we\u0026rsquo;ll use a dictionary to map the minimap_icon tags we gave our units to the corresponding marker:\nonready var icons = {\u0026#34;mob\u0026#34;: mob_marker, \u0026#34;alert\u0026#34;: alert_marker} Then we need a variable to hold the calculated ratio of map size to world size. We\u0026rsquo;ll use another dictionary to assign active markers to each object. The key will be the object (ie the Mob or Crate instance) and the value the assigned marker.\nvar grid_scale var markers = {} In _ready() we\u0026rsquo;ll center the player\u0026rsquo;s marker at the center of the grid. and calculate the scale factor. (Note: you should connect the resized signal and do both of these things in the callback if you have a dynamically sized UI).\nfunc _ready(): player_marker.position = grid.rect_size / 2 grid_scale = grid.rect_size / (get_viewport_rect().size * zoom) We\u0026rsquo;ll also create markers for every game object (using the \u0026ldquo;minimap_objects\u0026rdquo; group) by duplicating the matching marker node and tying the marker to the object via the markers dictionary:\nvar map_objects = get_tree().get_nodes_in_group(\u0026#34;minimap_objects\u0026#34;) for item in map_objects: var new_marker = icons[item.minimap_icon].duplicate() grid.add_child(new_marker) new_marker.show() markers[item] = new_marker Now that we have created the markers and linked each one to an object, we can update their positions in _process(). If no player is assigned, we\u0026rsquo;ll do nothing:\nfunc _process(delta): if !player: return If there is a player, we\u0026rsquo;ll first rotate the player marker to match the player\u0026rsquo;s heading. Since our PlayerMarker sprite points upwards rather than along the x axis, we must add 90 degrees:\nplayer_marker.rotation = get_node(player).rotation + PI/2 Next, we\u0026rsquo;ll find each object\u0026rsquo;s position relative to the player and use that to find the marker\u0026rsquo;s position (remembering to offset by grid.rect_size / 2 because the control\u0026rsquo;s origin is in the top left corner).\nfor item in markers: var obj_pos = (item.position - get_node(player).position) * grid_scale + grid.rect_size / 2 markers[item].position = obj_pos The problem with this is that markers can be placed outside the grid:\nTo fix this, after calculating obj_pos, but before setting the marker\u0026rsquo;s position, clamp it to the grid\u0026rsquo;s rectangle:\nobj_pos.x = clamp(obj_pos.x, 0, grid.rect_size.x) obj_pos.y = clamp(obj_pos.y, 0, grid.rect_size.y) Next, we can decide what to do about markers that are \u0026ldquo;off-screen\u0026rdquo; - when they would be outside the grid\u0026rsquo;s rectangle. Choose one of the following options (do this also before using clamp()). The first option is to hide them:\nif grid.get_rect().has_point(obj_pos + grid.rect_position): markers[item].hide() else: markers[item].show() The second is to change their appearance, in this case we\u0026rsquo;ll make them smaller to show they\u0026rsquo;re at a farther distance:\nif grid.get_rect().has_point(obj_pos + grid.rect_position): markers[item].scale = Vector2(0.75, 0.75) else: markers[item].scale = Vector2(1, 1) Removing objects If a mob gets killed or a crate picked up, the game will crash because the marker reference is no longer valid. We need a way to ensure markers are removed when the object is. Here\u0026rsquo;s a quick way to do this in our rudimentary demo setup:\nAdd signal removed to any object that you\u0026rsquo;ve put in the \u0026ldquo;minimap_objects\u0026rdquo; group. Emit this signal when the object is destroyed, along with a reference to itself so the map can identify it:\nemit_signal(\u0026#34;removed\u0026#34;, self) In the _ready() of the main script, connect these signals to the minimap:\nfunc _ready(): for object in get_tree().get_nodes_in_group(\u0026#34;minimap_objects\u0026#34;): object.connect(\u0026#34;removed\u0026#34;, $CanvasLayer/MiniMap, \u0026#34;_on_object_removed\u0026#34;) Now add the receiving function to the minimap script to free the marker and remove the reference:\nfunc _on_object_removed(object): if object in markers: markers[object].queue_free() markers.erase(object) Adjusting zoom If you\u0026rsquo;ve stuck with it this far, we have one more feature to add: adjustable zoom level. With this, scrolling the mouse wheel when hovering over the map will zoom its scale in and out.\nFirst, add a setget to the zoom property:\nexport var zoom = 1.5 setget set_zoom func set_zoom(value): zoom = clamp(value, 0.5, 5) grid_scale = grid.rect_size / (get_viewport_rect().size * zoom) On the MiniMap node, connect the _gui_input signal in the Inspector so we can process the scroll wheel events:\nfunc _on_MiniMap_gui_input(event): if event is InputEventMouseButton and event.pressed: if event.button_index == BUTTON_WHEEL_UP: self.zoom += 0.1 if event.button_index == BUTTON_WHEEL_DOWN: self.zoom -= 0.1 That\u0026rsquo;s it - observe the effect of scrolling in and out:\nWrapping up While this is a pretty big recipe, I\u0026rsquo;ve tried to make it flexible enough for you to incorporate into whatever project you\u0026rsquo;re working on.\nSome other things you might want to add:\n More marker types for different game objects. Adding new units when they\u0026rsquo;re spawned (hint: use a signal just like we did for removing units). Clicking on a marker to get info about it. Use a picture of your map as the minimap background instead of the grid.  Download the project file here: minimap.zip\n Related recipes  UI: Containers TileMap: using autotile Top-down character  Like video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_12/",
	"title": "Saving settings",
	"tags": [],
	"description": "",
	"content": " Saving settings We\u0026rsquo;ve added three toggle properties in the game - which works fine - but the settings aren\u0026rsquo;t preserved when we quit. We need to save those settings so the next time you run the game, they persist.\nFirst, we\u0026rsquo;ll define our settings file in res://settings.gd:\nvar settings_file = \u0026#34;user://settings.save\u0026#34; Next, we\u0026rsquo;ll add saving/loading functions for the three game settings that we want to save.\nfunc save_settings(): var f = File.new() f.open(settings_file, File.WRITE) f.store_var(enable_sound) f.store_var(enable_music) f.store_var(enable_ads) f.close() func load_settings(): var f = File.new() if f.file_exists(settings_file): f.open(settings_file, File.READ) enable_sound = f.get_var() enable_music = f.get_var() self.enable_ads = f.get_var() f.close() Call load_settings() in _ready() and save_settings() at the end of set_enable_ads(). Also, in Screens.gd we need to save the state when the sound/music settings change, so add settings.save_settings() in each of those parts of the match statement.\nAnother problem we\u0026rsquo;ll have is when the game starts, the icons in the settings menu won\u0026rsquo;t reflect the state that we just loaded from the save file. We can set that in register_buttons() which is already looping through all buttons to connect their signals:\nfor button in buttons: button.connect(\u0026#34;pressed\u0026#34;, self, \u0026#34;_on_button_pressed\u0026#34;, [button]) match button.name: \u0026#34;Ads\u0026#34;: if settings.enable_ads: button.text = \u0026#34;Disable Ads\u0026#34; else: button.text = \u0026#34;Enable Ads\u0026#34; \u0026#34;Sound\u0026#34;: button.texture_normal = sound_buttons[settings.enable_sound] \u0026#34;Music\u0026#34;: button.texture_normal = music_buttons[settings.enable_music] About screen The other thing we\u0026rsquo;ll add in this part is an \u0026ldquo;About\u0026rdquo; screen. This is where we\u0026rsquo;ll let the player know what the game\u0026rsquo;s all about and link to its license and to this page, since it is a tutorial game.\nComplying with license terms is very important. You can find out what\u0026rsquo;s required by Godot here: Complying with Licenses. Note that the art you\u0026rsquo;re using may also require credit, links, or other acknowledgement.\n To reach it, we\u0026rsquo;ve added a new button on the \u0026ldquo;Title\u0026rdquo; screen:\nThe button is setup just like the others - add it to the \u0026ldquo;buttons\u0026rdquo; group so that it will get registered. In the Screens.gd, add another match for this button\u0026rsquo;s name:\n\u0026#34;About\u0026#34;: change_screen($AboutScreen) Here\u0026rsquo;s what the \u0026ldquo;About\u0026rdquo; screen looks like:\nExtending \u0026ldquo;BaseScreen.tscn\u0026rdquo;, we\u0026rsquo;ve added a TextEdit and another container for a single \u0026ldquo;Home\u0026rdquo; button.\nIn the TextEdit, set BBCode enabled and put the following in the Text property:\n[center][u]Circle Jump[/u] [img]res://assets/images/godot_logo.png[/img][/center] Circle Jump is an open source tutorial game made with the Godot Game Engine. You can find the tutorial and the game\u0026#39;s source code here: [url=https://github.com/kidscancode/circle_jump]Circle Jump Source[/url] Copyright © 2019 KidsCanCode [url=https://github.com/kidscancode/circle_jump/blob/master/LICENSE]License Information[/url] See BBCode in RichTextLabel for details on how BBCode formatting works.\n To allow clicking on URLs, connect the meta_clicked signal of the TextEdit:\nfunc _on_TextEdit_meta_clicked(meta): OS.shell_open(meta) Follow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/touchscreen_camera/",
	"title": "Touchscreen Camera",
	"tags": [],
	"description": "",
	"content": " Problem You need a touch-controlled 2D camera for your mobile game.\nSolution In this recipe, we\u0026rsquo;ll create a generic 2D camera with multiple touch controls:\n Drag to pan Pinch to zoom  Setup Our camera will extend the built-in node, so add a Camera2D to a new scene and name it \u0026ldquo;TouchCamera\u0026rdquo;. Save and attach a script.\nHere are the variables we\u0026rsquo;ll need:\nextends Camera2D export (NodePath) var target # Optional: export these properties for convenient editing. var target_return_enabled = true var target_return_rate = 0.02 var min_zoom = 0.5 var max_zoom = 2 var zoom_sensitivity = 10 var zoom_speed = 0.05 var events = {} var last_drag_distance = 0 If a target is assigned, then the camera can follow and/or automatically return to it. The other properties that control how the camera works:\n target_return_enabled - If this is true, the camera will automatically return to the target after dragging. target_return_rate - Controls how fast the camera returns to its target. min_zoom / max_zoom - Limits how far you can zoom in/out. zoom_sensitivity - Sets how sensitive pinch-to-zoom will be - it\u0026rsquo;s the number of pixels\u0026rsquo; movement needed to \u0026ldquo;start\u0026rdquo; a zoom. zoom_speed - Used to smooth the zooming.  You can export these properties as well, if you\u0026rsquo;d like to be able to adjust them in the Inspector.\nThe other variables track the state of the camera. events is a dictionary that will hold the active touchscreen events, using the event\u0026rsquo;s index as its key. last_drag_distance keeps track of the distance between the two drag events in a \u0026ldquo;pinch\u0026rdquo; gesture.\nIn the _process() function, we\u0026rsquo;ll move the camera towards the target (if target return is enabled and there\u0026rsquo;s no touch event active).\nfunc _process(delta): if target and target_return_enabled and events.size() == 0: position = lerp(position, get_node(target).position, target_return_rate) This will allow us to pan the camera around and it will return to the player when we release the touch.\nNow we\u0026rsquo;re ready to start adding the gestures, starting with \u0026ldquo;pan\u0026rdquo;.\nPan You can test this gesture your computer by enabling \u0026ldquo;Emulate Touch From Mouse\u0026rdquo; in Project Settings -\u0026gt; Input Devices -\u0026gt; Pointing.\n Just like mouse or keyboard events, touch events extend InputEvent and follow the same input priority. We\u0026rsquo;ll use _unhandled_input() for processing so that other nodes, such as Control nodes, can process events first:\nfunc _unhandled_input(event): if event is InputEventScreenTouch: if event.pressed: events[event.index] = event else: events.erase(event.index) First we\u0026rsquo;re checking for a touch event (InputEventScreenTouch). We add the event to the events dictionary. The event\u0026rsquo;s index property is our dictionary\u0026rsquo;s key. We also remove the event if it\u0026rsquo;s not pressed, which means the touch has ended.\nNext, we need to handle a drag that comes after the touch:\nif event is InputEventScreenDrag: events[event.index] = event if events.size() == 1: position += event.relative * zoom.x If we get a drag event, we also add to the dictionary. Note that this will be updating the value - index 0 was already there from the first touch event, for example, and has now become a drag event.\nIf there\u0026rsquo;s only one event active, then this must be a one-finger drag, and we can adjust our camera\u0026rsquo;s position accordingly. Note that we need to scale the movement based on the current zoom, or else our drag movement will be disproportionately large when zoomed in and small when zoomed out.\nHere\u0026rsquo;s an example captured directly from a mobile device. The yellow circle indicates the touch location.\n Zoom You won\u0026rsquo;t be able to test this gesture on your computer because it requires 2 touch events, which the mouse can\u0026rsquo;t emulate.\n A \u0026ldquo;pinch\u0026rdquo; gesture will trigger the camera to zoom. This happens when we detect two drag events. If the drag events move toward each other, we\u0026rsquo;ll zoom in; away from each other, we\u0026rsquo;ll zoom out.\nif event is InputEventScreenDrag: events[event.index] = event if events.size() == 1: position += event.relative * zoom.x elif events.size() == 2: var drag_distance = events[0].position.distance_to(events[1].position) if abs(drag_distance - last_drag_distance) \u0026gt; zoom_sensitivity: var new_zoom = (1 + zoom_speed) if drag_distance \u0026lt; last_drag_distance else (1 - zoom_speed) new_zoom = clamp(zoom.x * new_zoom, min_zoom, max_zoom) zoom = Vector2.ONE * new_zoom last_drag_distance = drag_distance Here we handle the case of 2 active drag events. drag_distance tells us how far apart they are, and we can compare it with last_drag_distance to see if it\u0026rsquo;s larger or smaller. zoom_speed is a factor, so we\u0026rsquo;ll be multiplying the zoom by 1.05 (for zooming in) and 0.95 (for zooming out). We can then clamp the resulting zoom so that it doesn\u0026rsquo;t exceed our designated limits, and then assign the new zoom level. Finally, we update last_drag_distance for the next event.\n Wrapping up You can use this camera as a basis for your own camera needs. Here are some suggestions you can try to make yourself:\n Use lerp() to smooth the zooming. Automatically return zoom to default level. Double-tap to reset. Add more gestures -three fingers, etc.  For completeness, here\u0026rsquo;s the full TouchCamera.gd script:\nextends Camera2D export (NodePath) var target var target_return_enabled = true var target_return_rate = 0.02 var min_zoom = 0.5 var max_zoom = 2 var zoom_sensitivity = 10 var zoom_speed = 0.05 var events = {} var last_drag_distance = 0 func _process(delta): if target and target_return_enabled and events.size() == 0: position = lerp(position, get_node(target).position, target_return_rate) func _unhandled_input(event): if event is InputEventScreenTouch: if event.pressed: events[event.index] = event else: events.erase(event.index) if event is InputEventScreenDrag: events[event.index] = event if events.size() == 1: position += event.relative * zoom.x elif events.size() == 2: var drag_distance = events[0].position.distance_to(events[1].position) if abs(drag_distance - last_drag_distance) \u0026gt; zoom_sensitivity: var new_zoom = (1 + zoom_speed) if drag_distance \u0026lt; last_drag_distance else (1 - zoom_speed) new_zoom = clamp(zoom.x * new_zoom, min_zoom, max_zoom) zoom = Vector2.ONE * new_zoom last_drag_distance = drag_distance Download the project file here: 2d_touch_camera.zip\n Related recipes  Input: Input Actions Drag-select multiple units  Like video? Coming Soon   --\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/games/",
	"title": "Game Tutorials",
	"tags": [],
	"description": "",
	"content": "  Games Demo games and tutorials.\nIn this section:  Mobile Game: Circle Jump   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": "  Godot Recipes  Godot\u0026rsquo;s nodes are your ingredients. What can you cook up?\n Are you ready to learn game development? Whether it\u0026rsquo;s as a hobby or working towards your dream career, there\u0026rsquo;s never been a better time to get started. Modern programming languages and tools have made it easier than ever to build high-quality games and distribute them to the world. One of these tools is the Godot game engine. For beginners, it offers a friendly way to learn gamedev techniques. For experienced developers, it\u0026rsquo;s a powerful, customizable and open tool for bringing your visions to life.\nOn this site you\u0026rsquo;ll find a gentle introduction to the Godot game engine, as well as a wide variety of gamedev tips and techniques. Feel free to browse the categories in the sidebar and see what catches your interest.\nIf you\u0026rsquo;re new to Godot, start here: What is Godot?.\nHow to use this site Beginners If you\u0026rsquo;re new to game development, start with the \u0026ldquo;Godot 101: Basics\u0026rdquo; section. There you\u0026rsquo;ll find an introduction to the Godot application, and a step-by-step guide to creating your first project. There is a lot of material to absorb here. Don\u0026rsquo;t feel discouraged if you feel you don\u0026rsquo;t get it at first. Repetition is the key to learning complex topics; the more you work with Godot\u0026rsquo;s features, the more familiar and easy they will start to feel.\nIt\u0026rsquo;s assumed that you have at least some general programming experience. If you\u0026rsquo;re completely new to programming, click here for tips on how to get started.\n Experienced Developers If you\u0026rsquo;re an experienced developer and/or you\u0026rsquo;re familiar with other modern game engine(s), feel free to explore the menu on the left. You\u0026rsquo;ll find a number of useful guides and tutorials to show you how to do things the \u0026ldquo;Godot Way\u0026rdquo;. Code samples and example projects are available for all articles.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/recipes/godot3_inheritance/",
	"title": "Inheritance",
	"tags": [],
	"description": "",
	"content": " In this tutorial, we\u0026rsquo;ll explore how inheritance works in Godot. You can use inheritance in Godot to reuse code and create powerful hierarchies of object and scenes in your game.\nWe\u0026rsquo;ll imagine we\u0026rsquo;re making a classic top-down RPG and use Godot\u0026rsquo;s inheritance capabilities to create two different kinds of characters in the game.\nIntroduction In object oriented programming (OOP), inheritance is a powerful tool. Put briefly, you can define a class that inherits from another class. An object created using the first class will contain the methods and member variables of the \u0026ldquo;master\u0026rdquo; class as well as its own.\nGodot is strongly object-oriented, and offers the opportunity to use inheritance not just with objects (scripts) but also with scenes.\nHere\u0026rsquo;s a preview of what we\u0026rsquo;re making:\nThe green character is controlled by the player, and the other characters are NPCs, walking around the tile-based map semi-randomly.\nProject setup In Project Settings create four new input actions called \u0026ldquo;left\u0026rdquo;, \u0026ldquo;right\u0026rdquo;, \u0026ldquo;up\u0026rdquo;, and \u0026ldquo;down\u0026rdquo; and assign each of them to the matching arrow key. We\u0026rsquo;ll be using those names as dictionary keys, so make sure to note the spelling and capitalization.\nSet the display Width and Height to 640 by 480 (we\u0026rsquo;re using 32x32 tiles, so we don\u0026rsquo;t need much screen space for this demo).\nDownload the art (character spritesheets) and unzip it in the project folder.\nCreating Characters Both kinds of characters share a number of properties and functions:\n A spritesheet containing the 4-directional movement animations An AnimationPlayer to play the movement animations Grid-based movement (the character can only move one full \u0026ldquo;square\u0026rdquo; at a time) Collision detection with walls  We\u0026rsquo;ll start by creating a scene that will contain all of the above. Start with an Area2D and name it \u0026ldquo;Character\u0026rdquo;. Give it the following children:\n Sprite CollisionShape2D Tween (named MoveTween) AnimationPlayer  We\u0026rsquo;ll leave the Sprite without a texture for now, but in the Inspector set its Vframes and Hframes properties to 4 and 3 respectively.\nNext, create a RectangleShape2D in the collision shape and set its Extents property in the Inspector to (10, 18).\n NOTE: Because all the characters are drawn to the same scale, we can be confident that the same sized collision shape will work for all characters. If this isn\u0026rsquo;t the case with the art you\u0026rsquo;re using, you can skip setting the collision shape here and configure it later for the inherited scenes.\n Animations Create four animations in the AnimationPlayer node. Name them to match the four directions we used in the input actions. For each animation, we\u0026rsquo;re going to set the length to 0.8 and add a track for the Sprite\u0026rsquo;s Frame property. The pattern for each direction is listed below. See the screenshot for an example of the end result.\n   direction frames     left 9, 10, 11, 10   down 6, 7, 8, 7   right 3, 4, 5, 4   up 0, 1, 2, 1    Collision Detection Because the characters are moving on a grid, they will either move the full amount to the next tile or not at all. This means that before moving, the character needs to check if the move is possible. Add four RayCast2D nodes and set their names and Cast To properties as follows:\n   Name Cast To     RayCastRight (32, 0)   RayCastLeft (-32, 0)   RayCastDown (0, 32)   RayCastUp (0, -32)    Make sure to set the Enabled property on each one (RayCast2Ds are disabled by default). Your final node setup should look something like this:\nCharacter Script Now add a script to the Character node (it will automatically be named \u0026ldquo;Character.gd\u0026rdquo;).\nFirst, we\u0026rsquo;ll define our class variables:\nextends Area2D var tile_size = 32 var can_move = true var facing = \u0026#39;right\u0026#39; var moves = {\u0026#39;right\u0026#39;: Vector2(1, 0), \u0026#39;left\u0026#39;: Vector2(-1, 0), \u0026#39;up\u0026#39;: Vector2(0, -1), \u0026#39;down\u0026#39;: Vector2(0, 1)} var raycasts = {\u0026#39;right\u0026#39;: \u0026#39;RayCastRight\u0026#39;, \u0026#39;left\u0026#39;: \u0026#39;RayCastLeft\u0026#39;, \u0026#39;up\u0026#39;: \u0026#39;RayCastUp\u0026#39;, \u0026#39;down\u0026#39;: \u0026#39;RayCastDown\u0026#39;}  can_move is a flag that will track whether the character can move. It will be false while a movement is already underway. facing is the current direction of movement. Note that the moves and raycasts dictionaries\u0026rsquo; keys match the input actions we created.\nNext is the code that will execute a movement from one square to another:\nfunc move(dir): if get_node(raycasts[facing]).is_colliding(): return facing = dir can_move = false $AnimationPlayer.play(facing) $MoveTween.interpolate_property(self, \u0026#34;position\u0026#34;, position, position + moves[facing] * tile_size, 0.8, Tween.TRANS_SINE, Tween.EASE_IN_OUT) $MoveTween.start() return true We pass a direction to move(). If the RayCast2D for that direction detects a collision, the move is canceled. Otherwise, we change facing to that direction, disable movement, and start playing the matching animation. To actually execute the movement, we use the Tween node to interpolate the position property from its current value to its current value plus a 32-pixel movement in the given direction. The duration is set to 0.8 which matches the animation length.\n Note: See the Tween documentation for details on how the interpolate_property() method works.\n Finally, to enable movement again, we need to reset can_move when the movement has finished. Connect the tween_completed signal from MoveTween and add the following:\nfunc _on_MoveTween_tween_completed( object, key ): can_move = true Implementing the Player The player character needs to inherit all the properties we gave to Character as well as adding keyboard controlled movement.\nWe\u0026rsquo;ll start by making a new scene. However, instead of making a new empty scene, click on Scene -\u0026gt; New Inherited Scene in the menu. Select the Character.tscn. Rename the root node from \u0026ldquo;Character\u0026rdquo; to \u0026ldquo;Player\u0026rdquo; and save the new scene.\nAll we need to do for the Sprite is set the texture, so choose a character you like from the \u0026ldquo;res://art/rpgsprites1\u0026rdquo; folder and drag it to the Texture property.\nNext, we need a new script for the player, so remove the attached one (\u0026ldquo;Character.gd\u0026rdquo;) and attach a new one. In the \u0026ldquo;Attach Node Script\u0026rdquo; dialog, click the folder icon next to the Inherits option and choose \u0026ldquo;Character.gd\u0026rdquo;.\nHere\u0026rsquo;s our player script (note that it extends the character script):\nextends \u0026#34;res://Character.gd\u0026#34; func _process(delta): if can_move: for dir in moves.keys(): if Input.is_action_pressed(dir): move(dir) Because we\u0026rsquo;ve inherited all the behavior from \u0026ldquo;Character.gd\u0026rdquo;, we only need to worry about control. Here, we\u0026rsquo;re using the _process() function to check the keystate each frame. However, only if can_move allows it do we actually check the keys and call move().\nRun the scene and try it out.\nNPC characters Hopefully you\u0026rsquo;re seeing how inheritance works by now, but let\u0026rsquo;s make another type of character: an NPC that will wander around the screen randomly. Make another scene inheriting from \u0026ldquo;Character.tscn\u0026rdquo; and name it NPC.\nThis time, leave the sprite\u0026rsquo;s Texture blank and add a new script, again inheriting from \u0026ldquo;Character.gd\u0026rdquo;.\nextends \u0026#34;res://Character.gd\u0026#34; var textures = [\u0026#39;mage_f.png\u0026#39;, \u0026#39;mage_m.png\u0026#39;, \u0026#39;healer_f.png\u0026#39;, \u0026#39;healer_m.png\u0026#39;, \u0026#39;townfolk1_f.png\u0026#39;, \u0026#39;townfolk1_m.png\u0026#39;] func _ready(): randomize() var texture = textures[randi() % textures.size()] texture = load(\u0026#34;res://art/rpgsprites1/%s\u0026#34; % texture) $Sprite.texture = texture facing = moves.keys()[randi() % 4] func _process(delta): if can_move: if not move(facing) or randi() % 10 \u0026gt; 5: facing = moves.keys()[randi() % 4] This time, we\u0026rsquo;re using _ready() to select a random texture and assign it. We\u0026rsquo;re also choosing a random starting direction.\nAs with the player, we\u0026rsquo;ll use _process() to trigger the movement, but this time we\u0026rsquo;ll use the fact that the move() function returns true if it successfully executes (if the raycast detects an obstacle, it returns false). So if the NPC can\u0026rsquo;t move, it will pick a new random direction. For variety, we also add a 50% chance that it will change direction anyway.\nRun the scene and observe the NPC wandering randomly around the screen.\nTesting Collisions Finally, to confirm that the collision detection is working, let\u0026rsquo;s create a small scene for the characters to wander around in. We\u0026rsquo;ll use a TileMap to quickly draw our map.\n Note: See my Tilemap tutorial for details on using TileMaps in Godot.\n There are two tiles (\u0026ldquo;grass.png\u0026rdquo; and \u0026ldquo;stone.png\u0026rdquo;) in the art folder. There is also a TileSet called \u0026ldquo;tiles.tres\u0026rdquo; to save you the step of making your own. In it, only the stone tile has a collision shape, so it will be our obstacle.\nCreate a new \u0026ldquo;Main\u0026rdquo; scene (I usually like to use a plain Node as the root). Add a TileMap and drag \u0026ldquo;tileset.tres\u0026rdquo; into its Tile Set property. Also don\u0026rsquo;t forget to change the Size to (32, 32).\nDraw some walls as you like, and then add a Player instance and a few instances of NPC. Remember, the characters won\u0026rsquo;t know anything about the map - they just know if they can move one tile or not. If you want them to line up properly, you need to make sure the characters\u0026rsquo; starting positions are centered on a tile. This is easy to do if you turn on \u0026ldquo;Snap to Grid\u0026rdquo;. Click the \u0026ldquo;Use Snap\u0026rdquo; button and then open the grid menu by clicking on the three dots next to it:\nUnder \u0026ldquo;Configure Snap\u0026hellip;\u0026rdquo; set the Grid Step and Grid Offset:\nNow you can drag the instanced characters around and they\u0026rsquo;ll always snap to the center of a tile.\nConclusion Imagine we had built this project without using inheritance. The Player and NPC would each have their own scene setup and individual scripts. If we decided to change how we wanted movement to work, we would have to change everything twice. If we added more character types (Monsters, Pets, etc.) the duplicated code would multiply and quickly become unmanageable. With the setup we created above, everything is in one place, and any change to the character automatically propagates to everything that extends it.\nAs you\u0026rsquo;re working on your own projects, look for opportunities to consolidate code and use inheritance for your scenes and/or scripts. As your projects grow in size and complexity, it will quickly become a lifesaver.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://kidscancode.org/godot_recipes/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]